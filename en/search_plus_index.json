{"./":{"url":"./","title":"Introduction","keywords":"","body":" ____ __ /\\ __ \\ /\\ \\ \\ \\ \\/\\ \\ _\\_\\ \\ ` \\ \\_\\ \\_\\ /\\_____\\ Hello World! \\/_/\\/_/ \\/_____/ `(); NornJ(pronounced [ˈnɔ:ndʒeɪ]，abbreviated as nj) is a template engine that can works with React, JSX enhancement or alternative tools. Introduction In React development, the JSX can use almost all the syntax of javascript and it's very flexible. But if we use NornJ with React and JSX, we can do better, because it can gives JSX template engine features: Support control statements： {item} Support directives： Support filters： {n`${foo} | capitalize`} Support custom operators： NornJ presets the above JSX enhancement syntaxs, and also supports custom extensions of more syntaxs. It provides two kinds of similar API: JSX and Tagged templates, can adapt to the preferences of different users . Basic Use NornJ syntaxs in JSX(with styled-jsx)： class App extends Component { addTodo = e => { const { todos = [] } = this.state; this.setState({ todos: todos.concat(`Item ${todos.length}`) }); }; render({ page }, { todos = [] }) { return ( ` .app { padding: 20px; font-size: .75rem; } ` 5}> {todo * 2} 10}> {todo * 3} 0} onClick={this.addTodo}>Add Todo ); } } For above example, combining with the Babel plugin provided by NornJ, it is possible to write various new enhancement syntaxs in JSX. Use NornJ tagged templates syntaxs(with styled-components)： const template = html` 5}> {@item * 2} 10}> {@item * 3} 0}\" :onClick=\"addTodo\">Add Todo `; const Container = styled.div` padding: 20px; font-size: .75rem; `; class App extends Component { addTodo = e => { const { todos = [] } = this.state; this.setState({ todos: todos.concat(`Item ${todos.length}`) }); }; render() { return template({ components: { Container } }, this.state, this); } } In the above example, a template function was created using tagged templates API of NornJ. In this way, the template can be separated from the component logic code, and it also supports more concise writing than NornJ JSX API. Playground Use it in JSX NornJ playground(codesandbox) Use tagged templates NornJ playground(codepen) Install npm install babel-plugin-nornj-in-jsx #or yarn add babel-plugin-nornj-in-jsx Next, add nornj-in-jsx to plugins in your babel configuration: { \"plugins\": [ \"nornj-in-jsx\" ] } Boilerplate projects NornJ + React + Redux + React-Router + Webpack: react-redux-nornj-todomvc NornJ + React + Redux + React-Router(no need webpack): react-redux-nornj-todomvc-es5 NornJ + Backbone + Marionette(render html string): backbone-marionette-nornj-todomvc NornJ + React-Native + Styled-Components: nornj-react-native-counter NornJ + React + Mobx + React-Router: nornj-react-mst-boilerplate Tools nornj-react(React bindings) nornj-loader(Webpack loader) babel-plugin-nornj-in-jsx(Babel plugin provided by NornJ) babel-plugin-nornj-loader(nornj-loader's Babel plugin ver) react-native transformer(nornj-loader's RN ver) express-nornj(NornJ's Express view engine) Syntax highlight nornj-highlight(vscode) Browser support Supports all modern browsers and Internet Explorer 9+. License MIT "},"getting-started/why-nornj.html":{"url":"getting-started/why-nornj.html","title":"Why NornJ","keywords":"","body":"关于JSX的思考 我们平时都编写JSX来创建React组件，JSX非常好用，能适应各种各样的场景。依现状不难列出和JSX有关的以下几个话题： 按目前ecmascript的语法特性来看，原生的JSX语法在编写各种React组件时都能很好的适配。只是一些特殊情况可能存在争议，如在编写逻辑判断时需要使用ok ? ok : no或ok && ok; 我们不时会拿JSX和模板引擎进行优劣对比： JSX的主要优势：更灵活适合编写复杂逻辑、完善的IDE代码静态检查(如typescript的支持度)等; 模板引擎(例如Vue的模板)的主要优势：更丰富的语法糖、组件逻辑与表现分离(SFC)、容易扩展更多的语法(自定义过滤器、指令)等; JSX可以通过babel插件提供扩展，例如： 属css in js技术的styled-jsx：编译后有运行时代码，有3kb gzip的网络开销，但能提供不少JSX语法之外的辅助功能。 提供JSX流程控制的jsx-control-statements：编译后没有运行时代码，副作用小，但不可以支持扩展新的语法。 用babel插件让JSX吸收模板引擎的特性? 我们试想一下，JSX在如果在保持现有功能与特性的情况下，同时也拥有模板引擎的以下优点是不是会更好用？ 更丰富的语法糖(指令、流程控制等) 容易扩展更多的语法糖 以上我们通过babel插件就可以实现。NornJ是我们创造的一个可扩展并可支持React的模板引擎; 而它提供的配套babel插件则能够在用户并无感知的情况下，将模板引擎语法化整为零地插入到原生JSX中运行，如下： const test = props => ( //此行为模板 success //此行为原生JSX //此行为模板 fail //此行为原生JSX //此行为模板 //此行为模板 ); 下面的是一个在线可运行实例： 在线Playground(codesandbox) NornJ有哪些主要的语法糖 这些语法糖是如何工作的 扩展新的语法糖 NornJ其实是个完整的模板引擎 "},"getting-started/use-it-in-jsx.html":{"url":"getting-started/use-it-in-jsx.html","title":"Use JSX extension syntax","keywords":"","body":"在JSX中使用增强React开发体验 NornJ语法通过配套的babel插件可直接在JSX中编写，例如： const test = props => ( success fail ); 下面的是一个在线可运行实例： 在线Playground(codesandbox) 安装 npm install babel-plugin-nornj-in-jsx #or yarn add babel-plugin-nornj-in-jsx 然后配置.babelrc: { \"plugins\": [ \"nornj-in-jsx\" ] } {[1, 2, 3].map((item, i) => i > 1 ? {item + 1} : {item} )} ); } } ``` * NornJ ```js import nj, { template as t } from 'nornj'; import 'nornj-react'; export default class HelloWorld extends Component { render() { return t` 1}> {@item + 1} {@item} `; } } ``` 如上例，`NornJ`可使用`ES6+`的`tagged template literals`语法在js文件中描述模板，模板语法也直接支持处理各种逻辑，并且更贴近于html规范。 > 更多关于在js文件中编写`NornJ`模板的语法细节[请参考这里](../templateSyntax/templateString.md)。 ## NornJ和JSX相互嵌套使用 如果您不想完全使用`NornJ`替代`JSX`，那么`NornJ`也可以成为`JSX`的一个很好的辅助工具，例如可以使用`NornJ`的`if`及`each`等语法替代`JSX`中的`三目运算符`与`map`。 * 使用`if`替代`三目运算符`： ```js import nj, { template as t } from 'nornj'; import 'nornj-react'; export default class HelloWorld extends Component { render() { return ( {t` ${click me} ${} `} ); } } ``` * 使用`each`替代`map`： ```js import nj, { template as t } from 'nornj'; import 'nornj-react'; export default class HelloWorld extends Component { render() { return ( {t` 1}> #${({ item, index }) => {item + 1}} #${({ item, index }) => {index}} `} ); } } ``` 如上所示，`NornJ`与`JSX`的语法并不会发生冲突，可共存一起运行。这样即使无需修改您已有的代码，也可使用`NornJ`模板带来的各种语法糖。 > 如果在嵌套时`JSX`需要获取`NornJ`模板内产生的变量，如上例的`#each`中，这时可以使用`NornJ`提供的访问器属性语法获取，[具体参考这里](../templateSyntax/accessor.md)。 ## 在单独的文件中编写NornJ模板 `NornJ`模板除了可以在js文件中编写之外，还可以编写在单独的模板文件中，用来做组件(或页面)展现层与结构层的分离([具体文档请参考这里](../api/webpack.md))。例如编写一个`helloWorld.t.html`文件： ```html 1}> {@item + 1} {@item} ``` 然后可以在js文件中引入后使用： ```js import tmpls from './helloWorld.t.html'; export default class HelloWorld extends Component { render() { return tmpls.helloWorld(); //执行模板函数生成标签 } } ``` 如上，每个`*.t.html`文件内都可以定义一个或多个`template`标签。 这些`template`标签会在引用它的js文件中通过[nornj-loader](https://github.com/joe-sky/nornj-loader)进行解析，生成一个以`template`标签的`name`属性为key的模板函数集合对象，在各个组件的render中调用它们就会生成相应的标签。 ## 直接在JSX中使用 `NornJ`也提供了一个可以直接在JSX中编写的`babel`插件，写法如下： ```js const Button = () => { return ( less than 5 greater than 5 ) } ```--> 具体请见babel-plugin-nornj-in-jsx。 与各种React已有生态结合 NornJ可直接支持所有React现有生态，包括Redux、React-Router、Mobx、Ant Design等等，它可以和任何已有的React生态共存。 "},"jsx-syntax/":{"url":"jsx-syntax/","title":"JSX extension syntax","keywords":"","body":"NornJ 语法(JSX) NornJ可为JS/JSX增加的语法有以下这几类： 标签 主要用于为JSX扩充流程控制语句，例如循环： {item} 指令 主要用于为JSX扩充一种新的修改组件props的封装形式，例如修改组件style属性的display值： 过滤器 为JS/JSX扩充类似模板引擎的过滤器/管道语法，例如可将各类通用函数统一封装为过滤器使用： {n`${foo} | capitalize`} 运算符 可为JS/JSX扩充新的运算符，比如范围运算符： "},"jsx-syntax/tags.html":{"url":"jsx-syntax/tags.html","title":"Tags","keywords":"","body":"标签 在React开发中，NornJ提供了一种可扩展的特殊组件语法，称为标签。这种语法最常见的使用场景就是流程控制语句： const Test = props => ( success fail ); 上例中的、等都是标签语法。 与React组件的区别 简单地说，NornJ标签可以实现以下几种普通React组件无法实现的功能： 延迟渲染子节点 生成子节点可用的新变量 下面我们用实例分别解释下这些特性。 延迟渲染子节点 从上面的例子我们不难想到，其实用React的组件语法不是也是可以实现么？确实可以实现，比如react-if项目： const Foo = ({ data }) => ( {() => renderData(data) } Nothing to see here ); 但是可以看出，react-if需要一个额外的标签；而且文档中也注明了，如果不在或中写一个返回子节点的函数是会存在性能消耗的。因为在并不确定condition的值之前，所有的分支节点都没必要进行提前渲染。 然而NornJ的标签则不存在上述问题，因为它的本质并不是React组件而是一个模板函数，由配套的babel插件进行了转换： const test = props => ( nj` #${() => success} #${() => fail} `() ); 从上面可以看出，success等其实是包在函数内并没立即执行的。 另外，这并不是NornJ标签最终的运行时代码，NornJ配套的babel插件还会做进一步的模板预编译以提高性能。 生成子节点可用的新变量 例如循环： const Test = props => ( {item} ); 上例中使用NornJ的each标签实现了循环数组[1, 2, 3]，然后在子节点中使用新生成的item变量渲染循环中每一项的值。而常规JSX写法则必须使用函数才能实现： const Test = props => ( {[1, 2, 3].map(item => {item}} ); 上述虽然是官方常规写法，但是标签中插入的额外花括号、函数体等，可能或多或少会影响一点代码整体的可读性 。 下面是NornJ已有内置的标签： if 示例： const Test = props => ( This is a if tag demo. test if tag test1 ); 如上，如果if标签的condition参数计算结果为true，则会渲染if标签内的子节点；如为false则不会渲染if标签内的任何东西。 if标签的参数列表： 参数名称 类型 作用 condition Boolean if标签子节点的渲染条件 if标签还包含else、elseif等子标签。 else 示例： const Test = props => ( This is a if tag demo. test if tag test1 test2 ); 上例中如果if标签的condition参数值为false，则会渲染else标签内的子节点；否则会渲染if标签内除了else标签外的其他内容： ReactDOM.render(, document.body); /* 以上渲染内容为： This is a if tag demo. test2 */ elseif elseif标签可以实现多分支流程： const Test = props => ( 100}> 100 50}> 50 20}> 20 0 ); ReactDOM.render(, document.body); /* 以上渲染内容为： 20 */ elseif标签的参数列表： 参数名称 类型 作用 condition Boolean elseif标签子节点的渲染条件 each each标签可以实现循环： //要循环的数组 num: {item} //item表示使用数组项 no: {index} //index表示使用数组项索引值 在循环中内嵌if标签： show first //first表示数组第一项 show last //last表示数组最后一项 如要循环的数组为空，则可以渲染empty标签的内容： test {item.no} no data each标签的参数列表： 参数名称 类型 作用 of 数组 要循环的数组 item String 循环中生成的每项变量名，可以改变 index String 循环中生成的每项索引值变量名，可以改变 first String 循环中生成的第一项变量名，可以改变 last String 循环中生成的最后一项变量名，可以改变 for for标签是each标签的别名，用法是完全一样的： test {item.no} no data switch switch标签也可以实现多分支流程： const Test = props => ( 50 30 0 ); ReactDOM.render(, document.body); /* 以上渲染内容为： 30 */ switch和case标签的参数列表： 参数名称 类型 作用 value Any 在switch标签的value参数传入要判断值；然后其会和case标签中的value值进行===判断；所有case都不匹配时则渲染default标签的子节点 with with标签主要用于在JSX中创建新的变量： test-{num}-{i} MobxObserver 开发新的标签 NornJ的标签都是支持可扩展的，也就是说与React组件一样可以自行封装各种新功能。例如实现一个customIf标签： test if test else 每个标签都是一个函数，使用nj.registerExtension方法注册： nj.registerExtension('customIf', options => { const { props, children } = options; if (props.condition) { return children(); //输出标签的子节点，即\"test if\" } else { return props['else']; //输出else标签的子节点，即\"test else\" } }); 可以一次定义多个全局标签： nj.registerExtension({ customIf: options => {...}, customSwitch: options => {...} }); 标签扩展函数的options参数 参数名称 类型 作用 children Function 返回需要渲染的标签子节点 props Object 当前标签的各行内属性值(即中的a和b) 开发一个最简单的标签 更复杂的标签 附属标签 "},"jsx-syntax/directives.html":{"url":"jsx-syntax/directives.html","title":"Directives","keywords":"","body":"指令 指令即为在html元素开标签内编写的自定义属性，类似于Vue及Angular中的指令。语法为，用它可以封装一些实用功能，目的是写更少的代码去做更多的事情。在NornJ中，指令实质上是标签的一种特殊写法： 完全等价于： {false} 内置指令 目录 show mobx-bind mst-bind show 类似于Vue的v-show指令，#show用于切换元素是否显示，原理为修改style： const html = nj` test inline extension tag `({ isShow: false }); console.log(html); //test inline extension tag mobx-bind 类似于Vue的v-model指令，可以使用#mobx-bind配合Mobx在及等表单元素上创建双向数据绑定，它会根据控件类型自动选取正确的方法来更新元素。 在线示例(jsfiddle) source code 在线示例(codepen) 基本使用方法 import { Component } from 'react'; import { observable } from 'mobx'; import nj from 'nornj'; class TestComponent extends Component { @observable inputValue = ''; render() { return nj` `(this); } } 如上所示，无需编写标签的onChange事件，inputValue变量已自动和标签建立了双向数据绑定的关系。点这里是一个#mobx-bind结合表单组件的示例页面。 实质上，#mobx-bind的实现原理和v-model很类似，上述示例其实就是下面的语法糖形式： class TestComponent extends Component { @observable inputValue = ''; @autobind onChange(e) { this.inputValue = e.target.value; } render() { return nj` `(this); } } #mobx-bind和#mst-bind存放在nornj-react包中，需要按如下方式引入后方可使用： import 'nornj-react/mobx'; 另外如果使用nornj-loader，则需要在Webpack的配置中引入相应的扩展配置文件： module: { rules: [ { test: /\\.t.html(\\?[\\s\\S]+)*$/, use: [{ loader: 'nornj-loader', options: { outputH: true, delimiters: 'react', extensionConfig: require('nornj-react/mobx/extensionConfig') } }] }, ... ] } onChange事件 由于#mobx-bind默认自动设置了组件的onChange事件，但有些情况下我们可能还是需要在onChange中做一些其他的操作： class TestComponent extends Component { @observable inputValue = '1'; @autobind onChange(e) { console.log(e.target.value); } render() { return nj` `(this); } } 如上所示，onChange事件的行为和标签原生的onChange完全相同，它会在文本框的值变化后执行。 使用action更新变量 在mobx开发中如果启动严格模式或者使用mobx-state-tree时，则须要使用action来更新变量。可按下面方式配置使用action： import { observable, action, configure } from 'mobx'; // don't allow state modifications outside actions configure({enforceActions: true}); class TestComponent extends Component { @observable inputValue = '1'; @action.bound setInputValue(v) { this.inputValue = v; } render() { return nj` `(this); } } 当有action修饰符时，#mobx-bind会默认执行camel命名法(set + 变量名)定义的action，上例中为setInputValue。 mst-bind #mst-bind即为#mobx-bind的默认使用action来更新值的版本，用来配合mobx-state-tree的变量使用： store： import { types } from \"mobx-state-tree\"; const TestStore = types.model(\"TestStore\", { inputValue: '1' }) .actions(self => ({ setInputValue(v) { self.inputValue = v; } })); component： @inject('rootStore') @observer class TestComponent extends Component { render() { return nj` `({ testStore: this.props.rootStore.testStore }); } } 如上，#mst-bind会默认执行camel命名法(set + 变量名)定义的action来更新值，上例中为setInputValue。除此外#mst-bind的其他特性与上述的#mobx-bind完全相同。 目前mobx-bind和mst-bind默认支持的控件列表 控件名称 控件类型 备注 原生 和暂时不支持 原生 原生 暂时不支持 Ant Design Ant Design Ant Design Ant Design Ant Design Ant Design Ant Design 暂时不支持 Ant Design Ant Design Element-React Element-React 暂时不支持 Element-React Element-React Element-React Element-React Element-React Element-React Element-React Element-React Element-React Element-React   "},"tagged-templates-syntax/expressions.html":{"url":"tagged-templates-syntax/expressions.html","title":"表达式扩展语法","keywords":"","body":"表达式扩展语法 NornJ提供了一种在tagged templates语法中写表达式的功能，称为NornJ 表达式。主要用作增强现有的JS表达式，并实现过滤器等内建的新语法。使用方式很简单，即标签名为n的tagged templates： ReactDOM.render( <> ) /* 渲染结果： */ 表达式能做什么 简单地说，NornJ表达式中内建了一些常规JS语法不支持的特性： 过滤器 过滤器是什么？是一种在模板引擎(或含有模板引擎的框架，如Vue)中常见的功能，主要用于过滤展示数据。可参考Nunjucks的文档：https://mozilla.github.io/nunjucks/templating.html#filters。 NornJ过滤器的基本用法： {n`1234.567 | currency(2.05 | toInteger) | isString`} /* 例中先执行currency过滤器返回\"$1234.57\"，然后再执行isString过滤器判断是否字符串。 渲染结果：true */ 如上，过滤器的语法的常规模板引擎一致使用|符号作为分隔符，并且还支持为过滤器传参数和嵌套过滤器。更重要的是，还可以扩展出新的过滤器。 运算符 NornJ表达式中除了支持常规运算符外，还可以支持一些在常规JS语法中不支持的运算符，比如范围运算符..： {n`(1 .. 5).join('-')`} /* 例中\"1 .. 5\"的运算结果是一个含1-5的数组(即\"[1, 2, 3, 4, 5]\")，然后再执行数组的join方法用\"-\"连接每项。 渲染结果：1-2-3-4-5 */ 如上，此类自定义运算符是可以在NornJ表达式中同常规的JS语法一起运作。同过滤器一样，运算符也可以支持扩展出新的。 适配常规 JS 表达式 NornJ表达式对于常规的 JS 语法有非常好的适配性，例如下面列举的这些常用场景都可以支持： const Test = () => ( <> {n`1 + 2 * 3 - 4 / 5`} {n`1 4)`} {n`'abc'.trim() + 'def'.substr(1).length`} ); 使用变量 借助于Babel 插件的转换能力，NornJ表达式内可以直接使用当前作用域内可用的变量： const Test = props => { const str = 'abc'; const str2 = 'def'; return ( <> {n`props.a > (2 + 1) && !props.b {n`str.trim() + str2.substr(1).length`} ); }; 除了上述使用方法外，变量也可以通过tagged templates参数方式传入，效果是一样的： const Test = props => { const str = 'abc'; const str2 = 'def'; return ( <> {n`${props.a} > (2 + 1) && ${props}.b {n`${str}.trim() + ${str2}.substr(1).length`} ); }; 每个NornJ表达式计算后都会返回正确的类型，所以也可以和外部 JS 语法混合： const Test = props => ( <> {n`${props.a} > (2 + 1)` && n`${props}.b ); 插入过滤器等自定义语法 NornJ表达式内可以同时使用常规 JS 语法和过滤器等自定义语法，这正是它的特色： const Test = () => { const str = 'abc'; return ( <> {n`str.trim() | upperFirst`} {n`12345678 | currency`} {n`(1 .. 100).length * 100`} ); }; 表达式内目前不支持的语法 NornJ表达式虽然适配性很强，但当前还是有一些不支持的语法，如下： //注意，以下为一些目前不支持的语法 const Test = props => ( <> {n`!!12345`} {/* 只有1个!是支持的；多个!暂不支持 */} {n`12345++`} {/* 暂不支持自增等运算 */} {n`+12345`} {/* 暂不支持一元运算(!除外) */} {n`'12345'.map((item, i) => item)`} {/* 暂不支持定义函数体 */} ); //上面不支持的语法可以用原生JS语法弥补，这样改写： const Test2 = props => ( <> {!n`!12345`} {n`12345`++} {+n`12345`} {n`'12345'.map(${(item, i) => item})`} ); 不过，日后不排除NornJ会支持上述语法的可能性，已支持的语法已足够支撑常规开发使用。 另外，NornJ表达式的目标定位是为现有 JS 语法做增强，故它的内部或许并不需要实现全部的 JS 表达式。 过滤器 NornJ过滤器提供了一些常用内置功能，且完全可以支持用户扩展。 过滤器的管道与函数形式 NornJ的过滤器除了支持管道形式写法外，还可以支持用函数形式写法，效果是一样的： const Test = () => { const str = 'abc'; return ( <> {/* 管道形式 */} {n`str.trim() | upperFirst`} {n`12345678 | currency`} {/* 函数形式 */} {n`upperFirst(str.trim())`} {n`currency(12345678)`} ); }; 我们不妨对比一下过滤器的管道形式与函数形式写法，可发现管道形式的主要优势在于对于数据过滤看起来更为直观。 下面是NornJ的内置过滤器： 注意，内置过滤器只包含一些基础功能，例如很大一部分是NornJ底层必要使用的工具函数。NornJ的定位并不是一个类似Lodash的工具函数库，它的目标只是为常规JS开发提供过滤器这种新的扩展方式而已。 字符串处理 upperFirst upperFirst可以实现首字母大写： const Test = () => ( <> {n`'jack' | upperFirst`} ); //输出：Jack lowerFirst lowerFirst可以实现首字母小写： const Test = () => ( <> {n`'Jack' | lowerFirst`} ); //输出：jack camelCase camelCase可以将kebab-case字符串转换为camel-case： const Test = () => ( <> {n`'margin-left' | camelCase`} ); //输出：marginLeft 类型测定 isObject isObject用于检查类型是否为对象： const Test = ({ children }) => ( <> {n`children | isObject`} ); //输出：true isNumber isNumber用于检查类型是否为数字： const Test = ({ children }) => ( <> {n`children.length | isNumber`} ); //输出：true isString isString用于检查类型是否为字符串： const Test = ({ children }) => ( <> {n`children.length | isString`} ); //输出：false isArrayLike isArrayLike用于检查类型是否为类数组： const Test = ({ children }) => ( <> {n`children | isArrayLike`} ); //输出：true currency currency可以将数字转换货币形式： const Test = () => ( <> {n`98765 | currency`} {/* '$98,765.00' */} {n`98765.32132 | currency(2)`} {/* '$98,765.32' */} {n`98765.321 | currency(0, '￥')`} {/* '￥98,765' */} {n`'abc' | currency(2, '$', '-')`} {/* '-' */} ); 参数 用法 类型 默认值 作用 decimals 98765 | currency(decimals) Int 2 小数位 symbol 98765 | currency(2, symbol) String '$' 钱币符号 placeholder 98765 | currency(2, '￥', placeholder) String '' 如传入非数字，则输出占位符 另外，symbol和placeholder还可以进行全局配置： import nj from 'nornj'; nj.filterConfig.currency.symbol = '￥'; nj.filterConfig.currency.placeholder = '-'; toJS toJS即为Mobx的toJS方法： const Test = () => { const view = useLocalStore(() => ({ texts: ['abc', 'def'] })); return ( <> {JSON.stringify(n`view | toJS`)} ); }; 使用 Lodash NornJ的过滤器可以使用Lodash库的全部工具函数。它是一个过滤器的扩展，需要先这样全局引入一次： import 'nornj/lib/filter/lodash'; 然后就可以在NornJ表达式中使用了： const Test = () => ( <> {n`'-abc-' | repeat(3)`} {/* '-abc--abc--abc-' */} {n`'-abc-' | endsWith('bc-')`} {/* true */} {n`'Foo Bar' | snakeCase`} {/* 'foo_bar' */} ); 更多Lodash过滤器的使用方法请查看Lodash 文档。 开发新的过滤器 NornJ的过滤器都是支持可扩展的，可以自行封装各种新功能。 每个过滤器实际上是一个扩展函数，使用nj.registerFilter方法注册： import nj from 'nornj'; nj.registerFilter('2x', num => num * 2); //支持一次注册过个过滤器 nj.registerFilter({ '3x': num => num * 3, '4x': num => num * 4 }); console.log(n`100 | 2x | 3x | 4x`); //输出：2400 过滤器可以支持参数： import nj from 'nornj'; //从扩展函数的第二个参数开始定义过滤器的每个参数 nj.registerFilter('times', (num, times) => num * times); console.log(n`100 | times(10)`); //输出：1000 过滤器还可以支持嵌套： console.log(n`100 | times((10 * 2) | 3x)`); //输出：6000 上例中(10 * 2) | 3x的乘法运算需要加括号，是因为过滤器的运算优先级是最高的，并从左到右按顺序执行。 运算符 NornJ表达式中除了可以使用常规 JS 运算符外，还内置支持一些自定义的运算符，如%%、..等，并且还支持扩展出新的运算符。 可选链 NornJ表达式中的链式调用语法，默认全部都是可选链： const Test = props => ( <> {n`props.abc.length > 1`} {/* 不会报错 */} {props.abc.length > 1} {/* 报 props.abc 为 undefined 错误 */} {props?.abc?.length > 1} {/* 不会报错(使用 Babel 转换可选链语法) */} ); NornJ的可选链运算符在以下各种场景都可以正常使用，不会报错： const Test = props => ( <> {n`props[abc].length > 1`} {n`props.abc.substr(1) > 1`} {n`props[abc]().length > 1`} ); 与 Babel 转换的可选链语法(?.)相比，NornJ的可选链运算符由于不须要写?，所以使用和阅读都会很便捷。 但由于NornJ表达式内部目前不能支持定义函数体，所以有函数的场景可以这样使用： const Test = props => ( <> {/* 将函数体作为外部参数传入 NornJ 表达式 */} {n`props.data.map(${(item, i) => { return {item} }})`} ); 范围运算符 范围运算符可以快速生成数组： const Test = () => { const a = 10, b = 20; return ( <> {n`1 .. 10`} {/* [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] */} {n`(1 .. 10).length`} {/* 10 */} {n`(a .. b).length | includes(15)`} {/* true */} ); }; 半闭区间范围运算符 ..是闭区间的，NornJ还提供了它的半闭区间版本： const Test = () => { const a = 10, b = 20; return ( <> {n`1 .. {/* [1, 2, 3, 4, 5, 6, 7, 8, 9] */} {n`(1 .. {/* 9 */} {n`(a .. {/* false */} ); }; 飞船运算符 飞船运算符是一种比较运算，它按照大于、小于、等于三种结果，分别返回1、-1，0三种值： const Test = () => ( <> {n`1 10`} {/* -1 */} {n`1 1`} {/* 0 */} {n`10 1`} {/* 1 */} ); 向下取整运算符 NornJ内置了一种可实现向下取整的除法运算符，它的底层实现是Math.floor(value1 / value2)： const Test = () => ( <> {n`100 %% 30`} {/* 3 */} {n`56.78 %% 5`} {/* 11 */} {n`-56.78 %% 5`} {/* -12 */} ); 开发新的运算符 NornJ的运算符也都是支持可扩展的，可以自行封装各种新功能。 NornJ中的运算符本质上其实是过滤器的一种语法糖形式，目前可以做到自定义扩展出各种二元运算符。 每个运算符实际上是一个扩展函数，和过滤器一样使用nj.registerFilter方法注册： import nj from 'nornj'; //注册***运算符，功能为先进行乘法运算后，再乘上3倍 nj.registerFilter('***', (num, times) => num * times * 3); //支持一次注册过个运算符，功能和***类似 nj.registerFilter({ '****': (num, times) => num * times * 4, '*****': (num, times) => num * times * 5 }); 然后需要配置一下.babelrc： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"filterConfig\": { \"***\": { isOperator: true }, \"****\": { isOperator: true }, \"*****\": { isOperator: true } } } ] ] } 接着就可以在NornJ表达式中使用了： console.log(n`100***10`); //输出：100 * 10 * 3 = 3000 console.log(n`100***10****10`); //输出：100 * 10 * 3 * 10 * 4 = 120000 console.log(n`100***10****10*****10`); //输出：100 * 10 * 3 * 10 * 4 * 10 * 5 = 6000000 运算符的命名目前是有限制的，如包含下列字符则需要做特殊处理： [ '_', '#', '.', '>', ' 如运算符名称中包名含上述字符，则需要这样注册： import nj from 'nornj'; nj.registerFilter( '*.*', (num, times) => num * times * 3, { alias: '3x' //添加别名 } ); nj.registerFilter({ '*..*': { filter: (num, times) => num * times * 4, options: { alias: '4x' } }, '*...*': { filter: (num, times) => num * times * 5, options: { alias: '5x' } } }); 然后需要配置一下.babelrc： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"filterConfig\": { \"*.*\": { isOperator: true, alias: '3x' }, \"*..*\": { isOperator: true, alias: '4x' }, \"*...*\": { isOperator: true, alias: '5x' } } } ] ] } 接着就可以在NornJ表达式中使用了： console.log(n`100*.*10`); //输出：100 * 10 * 3 = 3000 console.log(n`100*.*10*..*10`); //输出：100 * 10 * 3 * 10 * 4 = 120000 console.log(n`100*.*10*..*10*...*10`); //输出：100 * 10 * 3 * 10 * 4 * 10 * 5 = 6000000 "},"jsx-syntax/expressions.html":{"url":"jsx-syntax/expressions.html","title":"Expressions","keywords":"","body":"过滤器与表达式 NornJ模板的插值变量中可以使用过滤器来对数据进行一些运算、过滤操作，语法和Vue 2.0中的过滤器较为类似。 另外，模板的插值变量中也支持一些常用的js表达式，如{{ [1, 2][0] * 3 }}。然而表达式语法实际上是过滤器的语法糖写法，这是NornJ与其他模板对比的一个很有特色的地方。故NornJ中可以支持js语法中并不支持的运算符如..、**等，且还可以自由扩展出更多的新运算符。 过滤器 过滤器语法为{插值变量 | 过滤器1 | 过滤器2...}，如使用多个过滤器则会按顺序依次执行，如下所示： //每个过滤器都是一个函数，使用nj.registerFilter方法全局注册 nj.registerFilter('2x', num => num * 2); console.log(nj`{{100 | +(50) | 2x}}`()); //输出300 可以一次定义多个全局过滤器： nj.registerFilter({ trim: obj => obj.trim(), replace: obj => obj.replace(/id/g, 'test1') }); 局部过滤器 还可以使用局部过滤器，将过滤器函数定义为插值变量即可： nj`{{1 | test}}`({ test: value => value + '_test' }); 过滤器参数 过滤器也可以添加参数，语法为{插值变量 | 过滤器1(参数1,参数2...) | 过滤器2(参数1,参数2...)...}。在过滤器方法中第一个参数是当前传入的数据；从第二个参数开始依次为这些模板中传入的参数，如下所示： nj.registerFilter('test', (obj, p1, p2) => { console.log(obj); //输出test console.log(p1); //输出1，过滤器参数的语法规则与插值语法相同 console.log(p2); //输出2，过滤器参数也可以传入插值变量动态求值 return obj; }); nj`{{data | test(1, arg2)}}`({ data: 'test', arg2: 2 }); 在过滤器的参数中也支持嵌套过滤器： ... 有参数的过滤器可以省略|符号，但是过滤器名称前必须有空格(至少一个空格或换行，除了几种特殊的过滤器，目前有.、_、#三个)，例如： =(0) ||(i ... 函数型过滤器 还可以直接以函数调用的方式来使用过滤器，称为函数型过滤器。语法为将过滤器名称当做函数调用即可，例如： {{ bool(1) }} 和 {{ 1 | bool }} 是等价的，结果都为true。 注意：函数型过滤器的前面可以不加空格。 过滤器内部的options参数 注册过滤器函数的最后一个参数即为options参数，它是一个对象类型。从options中可以获取到模板内部的一些值，主要用于实现一些复杂的模板扩展功能，如下所示： nj.registerFilter('test', function(val, options) { const ctx = options.context; console.log(ctx.getData('id')); //输出100 console.log(ctx.data[0]); //输出1 console.log(ctx.parent.data[0]); //输出{ list: [1] } console.log(ctx.index); //输出0 return val; }); nj` {{@index | test}} `({ list: [1] }, { id: 100 }); options参数列表(更多参数及细节待补充)： 参数名称 类型 作用 _njOpts Object 主要用在过滤器参数数量不固定时，用来判断是否为options参数 context Object 模板内部的上下文数据 lastValue Any 上一个的上一个过滤器的结果值，在过滤器函数内使用call及apply时可能会用到 表达式 过滤器只传一个参数时还支持省略扩号，这样就可以用类似js表达式的格式来编写，例如： {{i >=(0) ||(i 就可以改写为： {{i >= 0 || (i =\"、\" 这种使用过滤器的方式即为NornJ模板的表达式语法，实质上是编写过滤器的一种语法糖，规则为捕获过滤器名称后面的第一个变量(包含链式的变量)，正确的用法举例如下： {{1 + 2 * 3}} //结果为9 {{1 + (2 * 3)}} //结果为7 {{a + b.c}} {{a + b.c.trim() + d.e}} {{ { a: 1, b: 2 }.b * 100 }} //结果为200 {{ [1, 2, 3][0] + 100 }} //结果为101 NornJ表达式中的运算符暂时没有优先级的概念，它会从左至右执行各种运算，并使用括号控制优先级： {{1 + 2 * 3}} //结果为9 {{1 + (2 * 3)}} //结果为7 预计在NornJ未来的版本中会加入运算符优先级。 运算符两侧至少要有一个空格。请注意，以下语法都是错误的： {{1+2 * 3}} //语法错误，\"+\"的两端必须有空格 {{a -b.c}} //语法错误，\"-\"的两端必须有空格 {{a+ b.c.trim()+d.e}} //语法错误，\"+\"的两端必须有空格 使用上述错误的语法时，NornJ会在控制台发出相应的警告信息。 预计在NornJ未来的版本中会允许运算符两侧没有空格。 内置过滤器 表达式中的部分运算符及字面量(如a.b、{ a: 1 }、[1, 2]等)实际上都是过滤器的语法糖写法，具体请看内置过滤器。 "},"tagged-templates-syntax/":{"url":"tagged-templates-syntax/","title":"Tagged template expression","keywords":"","body":"模板语法 NornJ模板可以使用纯字符串或标签模板字符串(es6)构建，并可适应多种不同使用场景。模板结构与html非常相似，基本示例如下： this the test slider {{msg}}. 目录 插值变量 访问器属性 过滤器与表达式 内置过滤器 标签 内置标签 指令 模板注释 标签模板字符串(es6)语法 React开发中与JSX的不同点 "},"api/renderString.html":{"url":"api/renderString.html","title":"nj.compileH","keywords":"","body":"编译模板并渲染html字符串 每个NornJ模板都可以编译为1个模板函数。传入数据并执行此模板函数则可以输出html(或者是xml、普通文本，以下统一称为输出html)字符串，这样就可以配合Backbone、express、koa等框架作为视图的模板引擎了。 将纯字符串模板编译为模板函数 例： //定义模板 const tmpl = ` this the test demo{{no}}. test{{no}} `; //编译为模板函数 const tmplFn = nj.compile(tmpl, 'tmpl1'); 将纯字符串编译为模板函数须使用nj.compile方法，该方法第一个参数为纯字符串模板； 第二个参数为模板名称，该参数是可选的。如果设置了模板名称(模板名称应为全局唯一)，则下一次编译名称相同的模板时会直接从缓存中获取，这样就会提升很多性能。通常情况下推荐编译时设置该名称参数。 执行模板函数并输出html 例： //定义模板 const tmpl = ` this the test demo{{no}}. test{{no}} `; //编译为模板函数 const tmplFn = nj.compile(tmpl, 'tmpl1'); //输出html let html = tmplFn({ no: 100 }); console.log(html); /*输出html: this the test demo100. test100 */ 模板函数一般只传入一个参数，值为json格式的数据。模板中和传入数据中对应的值会自动进行相应替换，最后输出结果为替换后的html字符串。 模板函数的参数也可以传入多个json参数，如下所示： //定义模板 const tmpl = ` this the test demo{{no}}. test{{no2}} `; //编译为模板函数 const tmplFn = nj.compile(tmpl, 'tmpl1'); //渲染 let html = tmplFn({ no: 100 }, { no: 200, //相同的值优先采用顺序靠前的参数中的(1) no2: 300 //如果数组第一个参数没有no2属性，就会尝试从后面的参数中获取(2) }); console.log(html); /*输出html: this the test demo100. test300 传入多个参数后，NornJ模板函数在运行时会按顺序检测每个数据对象是否有和模板中对应的值。如果检测到前面的参数有对应值，那么就会停止继续检测后面的参数是否有该对应值，如例中(1)处所示；如果靠前面的参数中没有对应值，那么就按顺序寻找后面的参数中是否存在，如例中(2)处所示。 另外还可以用nj.render方法来执行渲染，它与nj.compile相比则是自动包含了编译模板函数的步骤： let html = nj.render(` this the test demo{{no}}. test{{no}} `, { no: 100 }); console.log(html); /*输出html: this the test demo100. test100 */ 如上，nj.render方法的第一个参数为纯字符串模板，从第二个参数开始和nj.compile编译出来的模板函数一样可以传入多个json参数。 使用标签模板字符串的方式定义模板 以nj为前置标签的模板字符串可以直接像模板函数一样执行，就和执行使用compile方法编译出来的模板函数的效果相同，如下所示： let html = nj`test{{no}}`({ no: 1 }); console.log(html); /*输出html: test1 */ "},"api/renderReact.html":{"url":"api/renderReact.html","title":"nj.renderH","keywords":"","body":"编译模板并渲染React组件 每个NornJ模板都可以编译为1个组件模板函数。传入数据并执行此模板函数则可以输出React虚拟dom组件对象，这样就可以配合React作为JSX的替代模板来开发组件了。 NornJ模板与JSX的不同点 NornJ模板使用字符串构建，无需预编译也可以直接使用，也可以选择预编译的方式；JSX在保证性能与网络开销的前提下，通常都是预编译的方式。 NornJ模板可以在React组件逻辑代码内编写，也可以用单独的文件编写；JSX通常只和React组件逻辑代码在一起编写。 在JSX中使用js表达式与html标签混合的语法来表达逻辑判断等；NornJ模板会提供完全声明式的标签语法，如if或循环语句等语法都为标签。 NornJ模板的解析方式和html更加类似，例如不加闭合的、等标签，以及style=\"margin-left:1px;\"等JSX不支持的语法在nj中都是可行的。另外NornJ模板还有一些语法如style等均与html更加一致，具体请见这里。 将纯字符串模板编译为模板函数 例： //定义模板 const tmpl = ` this the test demo{no}. test{no} `; //编译为模板函数 const tmplFn = nj.compileH(tmpl, 'tmpl1'); 将纯字符串编译为模板函数须使用nj.compileH方法。该方法第一个参数为纯字符串模板； 第二个参数为模板名称，该参数是可选的。如果设置了模板名称(模板名称应为全局唯一)，则下一次编译名称相同的模板时会直接从缓存中获取，这样就会提升很多性能。通常情况下推荐编译时设置该名称参数。 执行模板函数并输出React组件 import { compileH, registerComponent } from 'nornj'; import { Component } from 'react'; import { renderToStaticMarkup } from 'react-dom/server'; //定义模板 const tmpl = ` this the test demo{no}. test{no} `; //编译为模板函数 const template = compileH(tmpl, 'tmpl1'); //定义组件 class TestComponent extends Component { render() { return template({ no: this.props.no }); } } //注册组件到NornJ模板中 registerComponent('TestComponent', TestComponent); //输出React组件 let comp = compileH( '', 'tmpl2' )(); //使用renderToStaticMarkup方法输出html let html = renderToStaticMarkup(comp); 输出html： console.log(html); /* this the test demo100. test100 */ 模板函数一般只传入一个参数，值为json格式的数据。模板中和传入数据中对应的值会自动进行相应替换，最后输出结果为替换后的React vdom对象。 模板函数的参数也可以传入多个json参数，如下所示： //定义模板 const tmpl = ` this the test demo{no}. test{no2} `; //编译为模板函数 const tmplFn = nj.compileH(tmpl, 'tmpl1'); //渲染 let comp = tmplFn({ no: 100 }, { no: 200, //相同的值优先采用顺序靠前的参数中的(1) no2: 300 //如果数组第一个参数没有no2属性，就会尝试从后面的参数中获取(2) }); let html = renderToStaticMarkup(comp); console.log(html); /*输出html: this the test demo100. test300 */ 传入多个参数后，NornJ模板函数在运行时会按顺序检测每个数据对象是否有和模板中对应的值。如果检测到前面的参数有对应值，那么就会停止继续检测后面的参数是否有该对应值，如例中(1)处所示；如果靠前面的参数中没有对应值，那么就按顺序寻找后面的参数中是否存在，如例中(2)处所示。 另外还可以用nj.renderH方法来执行渲染，它与nj.compileH相比则是自动包含了编译模板函数的步骤： let comp = nj.renderH(` this the test demo{no}. test{no} `, { no: 100 }); let html = renderToStaticMarkup(comp); console.log(html); /*输出html: this the test demo100. test300 */ 如上，nj.renderH方法的第一个参数为纯字符串模板，从第二个参数开始和nj.compileH编译出来的模板函数一样可以传入多个json参数。 使用标签模板字符串的方式定义模板 以nj为前置标签的模板字符串可以直接像模板函数一样执行，就和执行使用compileH方法编译出来的模板函数的效果相同，如下所示： import { Component } from 'react'; import nj from 'nornj'; class TestComponent extends Component { render() { return nj` this the test demo{no}. test{no} `({ no: 1 }); } } 渲染Component.subComponent形式的组件 类似于JSX，NornJ模板中组件的标签名也可以使用的形式： ... ... registerTmpl registerTmpl采用es7装饰器的形式，可以使NornJ用更简洁的语法配合React使用，更多详情请见这里。 import { Component } from 'react'; import { registerTmpl } from 'nornj-react'; @registerTmpl({ name: 'TestComponent', //可传入组件名，相当于调用了nj.registerComponent注册组件，可选参数 template: ` this the test demo{no}. test{no} ` }) class TestComponent extends Component { render() { return this.template({ no: 1 }); //使用this.template方法渲染，该方法和nj.compileH编译的模板函数是一样的 } } 直接在模板函数中传入React组件 除了可以使用registerComponent或registerTmpl全局注册组件之外，还可以用以下几种方式直接在模板函数中局部使用React组件： (1) 在nj标签的模板字符中的标签名中，用${}的方式嵌入组件： import Icon from 'react-native-vector-icons/FontAwesome'; import Button from 'antd-mobile/lib/button'; nj` small `(); (2) 在模板函数的参数中，直接传入组件对象： import Icon from 'react-native-vector-icons/FontAwesome'; import Button from 'antd-mobile/lib/button'; nj` small `({ //标签名格式为\"{tagName}\" Button， Icon }); (3) 使用模板函数中的components参数传入组件，components参数只能写在模板函数的第一个参数中，需传入一个以组件名为key的对象： import Icon from 'react-native-vector-icons/FontAwesome'; import Button from 'antd-mobile/lib/button'; nj` small `({ //标签名格式和一般标签相同 components: { Button, Icon } }); components参数也可以传入数组，如下： ... nj` small `({ components: [{ Button }, { Icon }] }); "},"api/config.html":{"url":"api/config.html","title":"nj.config","keywords":"","body":"模板全局配置 NornJ模板可通过修改全局配置来定制一些功能，如插值变量的规则等。 通过nj.configAPI可设定各种全局配置，具体有： 名称 作用 delimiters 修改模板语法规则 outputH nj标签模板字符串返回的模板函数是否默认按hyperscript形式输出(即配合React的使用方式)，默认值为false。引入nornj-react包后该值默认设置为true。 createElement hyperscript形式的创建元素方法(即为React中的React.createElement)，默认值为null。引入nornj-react包后该值默认设置为React.createElement。 includeParser 模板中解析标签的方法，默认不添加到nj对象中。可以从nornj/tools/includeParser获取到这个函数，另外在nornj-loader内部会自动设置它。 textMode 是否使用文本模式解析，默认为false。 修改模板语法规则 目前可修改的语法规则有： import nj from 'nornj'; nj.config({ delimiters: { start: '{%', //插值变量开始字符，默认为\"{{\" end: '%}', //插值变量结束字符，默认为\"}}\" extension: '$', //标签前置字符，默认为\"#\" prop: '@-', //参数标签前置字符，默认为\"@\" comment: '##' //模板注释，默认为语法中的\"#\" } }); const html = nj` test1 this the test demo{%no%}. test{%no%} is {{'running'}} in client side `(); 如上例，可将模板规则替换为非默认规则的其他字符。利用这个可以实现用NornJ模板在node.js服务器端输出要在客户端运行的NornJ模板，因为语法规则不同，所以服务器端和客户端的模板不会发生冲突。 使用文本模式解析 NornJ在解析html字符串时默认全局使用非文本模式解析，解析方式和html非常类似，如下所示： test1 {'test2'} 以上模板会解析为下面这样，即会忽略多余的空格及换行符等： test1 test2 但有时候不需要去除多余空格，这在给普通的文本做替换参数时非常有用。那么就可以这样全局开启文本模式： nj.config({ textMode: true }); 这样上面的例子就会解析为： test1 test2 有些标签无论是否全局开启文本模式，它们的子节点都会使用文本模式解析，有如下几个标签： style script textarea xmp nj-text，自定义的特殊标签，解析时只生成它的子节点，示例如下： test1 {'test2'} 解析为： test1 test2 "},"api/webpack.html":{"url":"api/webpack.html","title":"With Webpack loader","keywords":"","body":"结合Webpack在单文件中编写模板 NornJ模板可以用纯字符串构建在单独的模板文件中，并可支持分模块构建，称为single-file templates(单文件模板)。它可以在以下几个场景使用： 在Webpack环境下使用nornj-loader引入单文件模板，loader如何配置请见这里。 在Node.js环境中(如Express服务器或React服务器端渲染)使用NornJ模板。 单文件模板的扩展名一般为这几种： *.nj.html、*.nj.htm、*.t.html、*.t.htm、*.nornj、*.nj 模板语法高亮插件 针对上述几种扩展名的单文件模板，我们提供了NornJ语法的高亮和智能提示插件： nornj-highlight(vscode) language-nornj(atom) 在单文件模板中定义单个模板 template.nj.html： this the test demo{no}. component.js： import template from './template.nj.html'; @registerTmpl('TestComponent') class TestComponent extends Component { render() { return template({ no: 1 }); } } /*渲染组件后输出html: this the test demo1. */ 在同一个单文件模板中定义多个模板 NornJ模板也可支持在一个单文件模板中定义多个模板，每个模板使用template标签定义，然后使用include标签引入： template.nj.html： this the tmplModule demo{no}. this the main demo{no}. template2.nj.html： this the tmplModule2 demo{no}. this the main2 demo{no}. component.js： import tmpls from './template.nj.html'; console.log(tmpls); //{ main:..., tmplModule2:... }，设置local属性的模板无法获取(6) @registerTmpl('TestComponent') class TestComponent extends Component { render() { return tmpls.main({ no: 1 }); //tmpls为对象结构，key值为html文件中template标签的name属性 } } /*渲染组件后输出html: this the tmplModule demo1. this the main2 demo1. this the tmplModule2 demo1. this the test demo1. */ 单文件模板可由多个template标签构成，每个template里放置独立的模板。 使用include块可以引入其他模板，分为几种情况如例中(2)、(3)、(4)处所示。 每个单文件模板中只能有一个name=\"main\"的template标签定义为主模板，如例中(1)处。 没有设置name属性的template标签会自动生成name=\"main\"属性，如例中(3)处所示。 template标签还可以设置local属性，这样它就只能在当前单文件模板内被其他模板使用，如例中(6)处。 在单文件模板中引入图片等资源 【v0.4.8新增】与webpack的默认方式相同，在模板中使用require方法引入相对路径资源即可： 另外，在v0.4.7及以前的版本中需要这样做： testImg.nj.html： testImg.js： import tmpls from './testImg.nj.html'; @registerTmpl('TestImg') class TestImg extends Component { render() { return tmpls.importImg({ imgSrc: require('../../images/test.png') }); //在js文件中使用require方法引入相对路径图片，再传到模板中 } } "},"api/htmlWebpackPlugin.html":{"url":"api/htmlWebpackPlugin.html","title":"Html-Webpack-Plugin","keywords":"","body":"结合Html-Webpack-Plugin Html-Webpack-Plugin是Webpack常用的用于生成静态html页面的插件，它内部使用的默认模板引擎为Lodash.template。但它也提供了使用第三方模板引擎的方式，使用相应的webpack-loader即可，具体文档在这里。 NornJ也提供了nornj-loader用于结合Webpack，故可直接支持Html-Webpack-Plugin。 配置nornj-loader Webpack配置项： module.exports = { ... module: { rules: [ ... { test: /\\.nj.html(\\?[\\s\\S]+)*$/, use: [{ loader: 'nornj-loader' }] }, ] }, plugins: [ new HtmlWebpackPlugin({ filename: '/index.html', template: './index.nj.html', inject: 'true', chunks: ['vendor', 'app'], path: `/dist/resources/` }) ] } 在html文件中使用NornJ语法 下面的html实例中使用了NornJ的with标签，作用是为了减少获取path参数的属性层级数： react-mst-boilerplate --> html模板文件经过nornj-loader解析后，会填充各变量并生成生产代码存放在dist/resources/index.html： react-mst-boilerplate --> "},"api/reactNative.html":{"url":"api/reactNative.html","title":"React-Native","keywords":"","body":"结合React-Native 可以直接在NornJ模板中使用React-Native提供的组件： import { AccessibilityInfo, ActivityIndicator, ART, Button, DatePickerIOS, DrawerLayoutAndroid, FlatList, Image, ... } from 'react-native'; nj` `() 使用nornj-react包中的react-native组件 在nornj-react包中提供一些默认封装的组件，可更方便地使用React-Native。 这样引入即可： import 'nornj-react/native'; 使用方法如下，和React-Native原生组件完全相同： nj` `() 在react-native中使用单文件组件 在RN项目的根目录下创建rn-cli.config.js，然后这样配置 module.exports = { getTransformModulePath() { return require.resolve('./node_modules/nornj/tools/metroTransformer'); }, getSourceExts() { return ['htm', 'nj', 'nornj']; } }; 然后就可以在RN中使用NornJ的单文件组件了： {counter} / times + - Increment if odd Increment async Decrement async Set to zero 具体请看下面的实例项目。 NornJ + React-Native的实例项目 计数器示例[react-native + styled-components + nornj] "},"api/redux.html":{"url":"api/redux.html","title":"Redux","keywords":"","body":"结合Redux 可以直接在NornJ模板中使用Redux提供的组件： import { Provider } from 'react-redux'; nj` `() 使用nornj-react包中的redux组件 在nornj-react包中提供一些默认封装的组件，可更方便地使用Redux。 这样引入即可： import 'nornj-react/redux'; 组件列表： nornj-react中的组件名称 对应的Redux组件 Provider Provider 使用方法如下，和Redux原生组件完全相同： nj` `() NornJ + Redux的实例项目 todomvc[react + redux + react-router + nornj + webpack4] todomvc(无需webpack打包)[react + redux + react-router + nornj] 计数器示例[react-native + styled-components + nornj] "},"api/reactRouter.html":{"url":"api/reactRouter.html","title":"React-Router","keywords":"","body":"结合React-Router 可以直接在NornJ模板中使用React-Router提供的组件： import { BrowserRouter, HashRouter, Link, MemoryRouter, NavLink, Prompt, Redirect, Route, Router, StaticRouter, Switch } from 'react-router-dom'; nj` `() 使用nornj-react包中的react-router组件 在nornj-react包中提供一些默认封装的组件，可更方便地使用React-Router。 这样引入即可： import 'nornj-react/router'; 组件列表： nornj-react中的组件名称 对应的React-Router组件 BrowserRouter BrowserRouter HashRouter HashRouter router-Link Link MemoryRouter MemoryRouter router-NavLink NavLink router-Prompt Prompt Redirect Redirect Route Route Router Router StaticRouter StaticRouter router-Switch Switch 使用方法如下，和React-Router原生组件完全相同： nj` `() NornJ + React-Router的实例项目 todomvc[react + redux + react-router + nornj + webpack4] todomvc(无需webpack打包)[react + redux + react-router + nornj] "},"api/mobx.html":{"url":"api/mobx.html","title":"Mobx","keywords":"","body":"结合Mobx 可以直接在NornJ模板中使用Mobx提供的组件： import { Provider } from 'mobx-react'; nj` `() 使用nornj-react包中的mobx组件与扩展 在nornj-react包中提供一些默认封装的组件和扩展，可更方便地使用Mobx。 这样引入即可： import 'nornj-react/mobx'; 组件 nornj-react中的组件名称 对应的Mobx组件 mobx-Provider Provider 使用方法如下，和Mobx原生组件完全相同： nj` `() 过滤器 nornj-react中的过滤器名称 对应的Mobx方法 toJS toJS 使用方法如下，和Mobx原生方法完全相同： nj` --> `() 指令 针对Mobx我们提供了实现双向绑定的指令#mobx-model，具体请见这里。 NornJ + Mobx的实例项目 由于Mobx是我们主力使用的React状态管理库，所以我们创建了完整的前端脚手架用于快速开发项目： nornj-cli 该脚手架的使用方法类似于vue-cli，目前可创建完整的基于react + mobx的项目模板，并有快速上手文档。 项目脚手架源码[react + mobx + react-router + nornj] "},"api/reactUI.html":{"url":"api/reactUI.html","title":"React UI libraries","keywords":"","body":"结合React第三方ui库 NornJ模板中可以直接使用React第三方ui库提供的组件，具体请看这里。 使用Ant Design组件 对于Ant Design组件我们做了简单的封装，可更方便地使用，具体请看这里。 "}}