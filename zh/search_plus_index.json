{"./":{"url":"./","title":"概述","keywords":"","body":" ____ __ /\\ __ \\ /\\ \\ \\ \\ \\/\\ \\ _\\_\\ \\ ` \\ \\_\\ \\_\\ /\\_____\\ Hello World! \\/_/\\/_/ \\/_____/ `(); NornJ(读音[ˈnɔ:ndʒeɪ]，简称nj)是一个可以同React一起工作的模板引擎，JSX的增强或替代工具。 概述 React的JSX几乎可以使用javascript的全部语法且非常灵活，可配合babel适应各种复杂的使用场景。但是，使用NornJ配合React开发还能做得更好，因为它能给JSX带来模板引擎的特性： 支持流程控制语法： {item} 支持指令语法： 支持过滤器语法： {n`${foo} | capitalize`} 支持自定义运算符： NornJ不仅有预置的上述几类可增强JSX的语法，并且还实现了支持用户扩展更多的语法。NornJ还同时提供了JSX和tagged templates两套几乎相同的语法API，以适应不同用户的口味 基本示例 直接在JSX中使用(结合styled-jsx)： class App extends Component { addTodo = e => { const { todos = [] } = this.state; this.setState({ todos: todos.concat(`Item ${todos.length}`) }); }; render({ page }, { todos = [] }) { return ( ` .app { padding: 20px; font-size: .75rem; } ` 5}> {todo * 2} 10}> {todo * 3} 0} onClick={this.addTodo}>Add Todo ); } } 如上例，配合NornJ提供的配套babel插件，便可以在JSX中编写各种新的增强语法。 使用tagged templates语法(结合styled-components)： const template = nj` 5}> {@item * 2} 10}> {@item * 3} 0}\" :onClick=\"addTodo\">Add Todo `; const Container = styled.div` padding: 20px; font-size: .75rem; `; class App extends Component { addTodo = e => { const { todos = [] } = this.state; this.setState({ todos: todos.concat(`Item ${todos.length}`) }); }; render() { return template({ components: { Container } }, this.state, this); } } 上例中使用了NornJ的tagged templates API创建了一个模板函数，它可以做到与React组件的逻辑代码分离，并且还能支持比JSX API更加简练的写法。 在线演示地址 使用JSX 在线Playground(codesandbox) 使用tagged templates 在线Playground(codepen) 安装 npm install babel-plugin-nornj-in-jsx@next #or yarn add babel-plugin-nornj-in-jsx@next 然后配置.babelrc: { \"plugins\": [ \"nornj-in-jsx\" ] } 示例项目 NornJ + React + Redux + React-Router + Webpack: react-redux-nornj-todomvc NornJ + React + Redux + React-Router(无需webpack打包): react-redux-nornj-todomvc-es5 NornJ + Backbone + Marionette(渲染html字符串): backbone-marionette-nornj-todomvc NornJ + React-Native + Styled-Components: nornj-react-native-counter NornJ + React + Mobx + React-Router: nornj-react-mst-boilerplate 相关项目及工具 nornj-react(React适配库) nornj-loader(Webpack loader) babel-plugin-nornj-in-jsx(支持在JSX中写NornJ语法的Babel插件) babel-plugin-nornj-loader(nornj-loader的Babel插件版) react-native transformer(nornj-loader的RN版) express-nornj(NornJ适配Express的视图引擎) 语法高亮插件 nornj-highlight(vscode) 浏览器支持 可支持所有现代浏览器以及Internet Explorer 9+。 License MIT "},"getting-started/why-nornj.html":{"url":"getting-started/why-nornj.html","title":"为什么要开发 NornJ","keywords":"","body":"关于JSX的思考 我们平时都编写JSX来创建React组件，JSX非常好用，能适应各种各样的场景。依现状不难列出和JSX有关的以下几个话题： 按目前ecmascript的语法特性来看，原生的JSX语法在编写各种React组件时都能很好的适配。只是一些特殊情况可能存在争议，如在编写逻辑判断时需要使用ok ? ok : no或ok && ok; 我们不时会拿JSX和模板引擎进行优劣对比： JSX的主要优势：更灵活适合编写复杂逻辑、完善的IDE代码静态检查(如typescript的支持度)等; 模板引擎(例如Vue的模板)的主要优势：更丰富的语法糖、组件逻辑与表现分离(SFC)、容易扩展更多的语法(自定义过滤器、指令)等; JSX可以通过babel插件提供扩展，例如： 属css in js技术的styled-jsx：编译后有运行时代码，有3kb gzip的网络开销，但能提供不少JSX语法之外的辅助功能。 提供JSX流程控制的jsx-control-statements：编译后没有运行时代码，副作用小，但不可以支持扩展新的语法。 用babel插件让JSX吸收模板引擎的特性? 我们试想一下，JSX在如果在保持现有功能与特性的情况下，同时也拥有模板引擎的以下优点是不是会更好用？ 更丰富的语法糖(指令、流程控制等) 容易扩展更多的语法糖 以上我们通过babel插件就可以实现。NornJ是我们创造的一个可扩展并可支持React的模板引擎; 而它提供的配套babel插件则能够在用户并无感知的情况下，将模板引擎语法化整为零地插入到原生JSX中运行，如下： const test = props => ( //此行为模板 success //此行为原生JSX //此行为模板 fail //此行为原生JSX //此行为模板 //此行为模板 ); 下面的是一个在线可运行实例： 在线Playground(codesandbox) "},"getting-started/use-it-in-jsx.html":{"url":"getting-started/use-it-in-jsx.html","title":"快速起步","keywords":"","body":"在JSX中使用增强React开发体验 NornJ语法通过配套的babel插件可直接在JSX中编写，例如： const test = props => ( success fail ); 下面的是一个在线可运行实例： 在线Playground(codesandbox) 安装 npm install babel-plugin-nornj-in-jsx@next #or yarn add babel-plugin-nornj-in-jsx@next 然后配置.babelrc: { \"plugins\": [ \"nornj-in-jsx\" ] } {[1, 2, 3].map((item, i) => i > 1 ? {item + 1} : {item} )} ); } } ``` * NornJ ```js import nj, { template as t } from 'nornj'; import 'nornj-react'; export default class HelloWorld extends Component { render() { return t` 1}> {@item + 1} {@item} `; } } ``` 如上例，`NornJ`可使用`ES6+`的`tagged template literals`语法在js文件中描述模板，模板语法也直接支持处理各种逻辑，并且更贴近于html规范。 > 更多关于在js文件中编写`NornJ`模板的语法细节[请参考这里](../templateSyntax/templateString.md)。 ## NornJ和JSX相互嵌套使用 如果您不想完全使用`NornJ`替代`JSX`，那么`NornJ`也可以成为`JSX`的一个很好的辅助工具，例如可以使用`NornJ`的`if`及`each`等语法替代`JSX`中的`三目运算符`与`map`。 * 使用`if`替代`三目运算符`： ```js import nj, { template as t } from 'nornj'; import 'nornj-react'; export default class HelloWorld extends Component { render() { return ( {t` ${click me} ${} `} ); } } ``` * 使用`each`替代`map`： ```js import nj, { template as t } from 'nornj'; import 'nornj-react'; export default class HelloWorld extends Component { render() { return ( {t` 1}> #${({ item, index }) => {item + 1}} #${({ item, index }) => {index}} `} ); } } ``` 如上所示，`NornJ`与`JSX`的语法并不会发生冲突，可共存一起运行。这样即使无需修改您已有的代码，也可使用`NornJ`模板带来的各种语法糖。 > 如果在嵌套时`JSX`需要获取`NornJ`模板内产生的变量，如上例的`#each`中，这时可以使用`NornJ`提供的访问器属性语法获取，[具体参考这里](../templateSyntax/accessor.md)。 ## 在单独的文件中编写NornJ模板 `NornJ`模板除了可以在js文件中编写之外，还可以编写在单独的模板文件中，用来做组件(或页面)展现层与结构层的分离([具体文档请参考这里](../api/webpack.md))。例如编写一个`helloWorld.t.html`文件： ```html 1}> {@item + 1} {@item} ``` 然后可以在js文件中引入后使用： ```js import tmpls from './helloWorld.t.html'; export default class HelloWorld extends Component { render() { return tmpls.helloWorld(); //执行模板函数生成标签 } } ``` 如上，每个`*.t.html`文件内都可以定义一个或多个`template`标签。 这些`template`标签会在引用它的js文件中通过[nornj-loader](https://github.com/joe-sky/nornj-loader)进行解析，生成一个以`template`标签的`name`属性为key的模板函数集合对象，在各个组件的render中调用它们就会生成相应的标签。 ## 直接在JSX中使用 `NornJ`也提供了一个可以直接在JSX中编写的`babel`插件，写法如下： ```js const Button = () => { return ( less than 5 greater than 5 ) } ```--> 具体请见babel-plugin-nornj-in-jsx。 与各种React已有生态结合 NornJ可直接支持所有React现有生态，包括Redux、React-Router、Mobx、Ant Design等等，它可以和任何已有的React生态共存。 "},"jsx-syntax/":{"url":"jsx-syntax/","title":"JSX 扩展语法","keywords":"","body":"JSX扩展语法 NornJ可为JS/JSX增加的语法有以下这几类： 标签 主要用于为JSX扩充流程控制语句，例如循环： {item} 指令 主要用于为JSX扩充一种新的修改组件props的封装形式，例如修改组件style属性的display值： 过滤器 为JS/JSX扩充类似模板引擎的过滤器/管道语法，例如可将各类通用函数统一封装为过滤器使用： {n`${foo} | capitalize`} 运算符 可为JS/JSX扩充新的运算符，比如范围运算符： "},"jsx-syntax/tags.html":{"url":"jsx-syntax/tags.html","title":"标签","keywords":"","body":"标签 NornJ提供了一种语法同React类似、并且可扩展的特殊组件语法，称为标签。这种语法最常见的使用场景就是流程控制语句： const Test = props => ( success fail ); 上例中的、等都是标签语法。 与React组件的区别 简单地说，NornJ标签可以实现以下几种普通React组件无法实现的功能： 延迟渲染子节点 生成子节点可用的新变量 下面我们用实例分别解释下这些特性。 延迟渲染子节点 从上面的例子我们不难想到，其实用React的组件语法不是也是可以实现么？确实可以实现，比如react-if： import { If, Then, Else } from 'react-if'; const Foo = ({ data }) => ( {() => renderData(data) } Nothing to see here ); 但是可以看出，react-if需要一个额外的标签；而且文档中也注明了，如果不在或中写一个返回子节点的函数是会存在性能消耗的。因为在并不确定condition的值之前，所有的分支节点都没必要进行提前渲染。 然而NornJ的标签则不存在上述问题，因为它的本质并不是React组件而是一个模板函数，由配套的babel插件进行了转换： const test = props => ( nj.renderH(` {#_njParam1} {#_njParam2} `, { _njParam0: props.isTest, _njParam1: () => success, _njParam2: () => fail }); ); 从上面可以看出，success等其实是包在函数内并没立即执行的。 另外，这并不是NornJ标签最终的运行时代码，NornJ配套的babel插件还会做进一步的模板预编译以提高性能。 生成子节点可用的新变量 例如循环： const Test = props => ( {item} ); 上例中使用NornJ的each标签实现了循环数组[1, 2, 3]，然后在子节点中使用新生成的item变量渲染循环中每一项的值。而使用常规JSX写法的组件则必须使用函数才能实现，比如react-loops： import { For } from 'react-loops'; const Test = props => ( {item => {item} } ); 上述虽然是JSX的常规写法，但是标签子节点中插入的额外花括号、函数体等，可能或多或少还是增加了少量代码，以及影响了一点点标签嵌套的可读性。 下面是NornJ已有内置的标签： If 示例： const Test = props => ( This is a if tag demo. test if tag test1 ); 如上，如果if标签的condition参数计算结果为true，则会渲染if标签内的子节点；如为false则不会渲染if标签内的任何东西。 if标签的参数列表： 参数名称 类型 作用 condition Boolean if标签子节点的渲染条件 if标签还包含else、elseif等子标签。 Else 示例： const Test = props => ( This is a if tag demo. test if tag test1 test2 ); 上例中如果if标签的condition参数值为false，则会渲染else标签内的子节点；否则会渲染if标签内除了else标签外的其他内容： ReactDOM.render(, document.body); /* 以上渲染内容为： This is a if tag demo. test2 */ Elseif elseif标签可以实现多分支流程： const Test = props => ( 100}> 100 50}> 50 20}> 20 0 ); ReactDOM.render(, document.body); /* 以上渲染内容为： 20 */ elseif标签的参数列表： 参数名称 类型 作用 condition Boolean elseif标签子节点的渲染条件 Each each标签可以实现循环： //要循环的数组 num: {item} //item表示使用数组项 no: {index} //index表示使用数组项索引值 在循环中内嵌if标签： show first //first表示数组第一项 show last //last表示数组最后一项 如要循环的数组为空，则可以渲染empty标签的内容： test {item.no} no data each标签的参数列表： 参数名称 类型 作用 of 数组 要循环的数组 item String 循环中生成的每项变量名，可以改变 index String 循环中生成的每项索引值变量名，可以改变 first String 循环中生成的第一项变量名，可以改变 last String 循环中生成的最后一项变量名，可以改变 For for标签是each标签的别名，用法是完全一样的： test {item.no} no data Switch switch标签也可以实现多分支流程： const Test = props => ( 50 30 0 ); ReactDOM.render(, document.body); /* 以上渲染内容为： 30 */ switch和case标签的参数列表： 参数名称 类型 作用 value Any 在switch标签的value参数传入要判断值；然后其会和case标签中的value值进行===判断；所有case都不匹配时则渲染default标签的子节点 With with标签主要用于在JSX中创建新的变量： test-{num}-{i} MobxObserver mobxObserver标签实际上就是mobx-react-lite库的observer组件，只不过它在编写时无需在子节点写函数： import { Observer, useObservable } from \"mobx-react-lite\" function ObservePerson(props) { const person = useObservable({ name: \"John\" }) return ( {person.name} {/* 原生写法 */} { () => {person.name} } {/* MobxObserver标签 */} {person.name} (person.name = \"Mike\")}>No! I am Mike ) } 开发新的标签 NornJ的标签都是支持可扩展的，也就是说与React组件一样可以自行封装各种新功能。 开发一个最简单的标签 例如实现一个Unless标签，功能即为与If标签相反，它的condition属性为false时才渲染子节点： Test unless 上面的Unless标签实际上是一个扩展函数，使用nj.registerExtension方法注册： import nj from 'nornj'; nj.registerExtension( 'unless', //注意：标签名称需要使用小写开头的camel命名方式 options => { const { props, children } = options; if (!props.condition) { return children(); //输出标签的子节点：Test unless } } ); 然后还需要配置一下.babelrc，因为这样配套的babel插件才知道需要对Unless标签进行转换： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"extensionConfig\": { \"unless\": true } } ] ] } 这样我们就成功开发了一个Unless标签，与普通React组件不同的是，它可以获得NornJ标签的延迟渲染子节点特性。 标签扩展函数的options参数 参数名称 类型 作用 children Function 执行后返回需要渲染的标签子节点，与React的props.children不同，它是函数 props Object 当前标签的属性值(即中的a和b，这里与React组件一致) 更复杂的标签 上面的例子我们介绍了如何开发一个最简单的标签Unless，它只需在扩展函数内按照一定条件判断是否返回子节点就可以了；也无需配置更多的extensionConfig配置参数，填写true即可。 接下来我们实现一个循环标签SimpleFor，用法如下： Test for: {loopItem} 我们还注意到上面循环体中的loopIndex与loopItem是该标签生成出来的新变量，也就是获得了NornJ标签的生成子节点可用的新变量特性。这就需要配置extensionConfig的newContext参数： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"extensionConfig\": { \"simpleFor\": { \"newContext\": { \"data\": { \"index\": \"loopIndex\", \"item\": \"loopItem\", \"first\": \"loopFirst\" } } } } } ] ] } 然后使用nj.registerExtension方法注册标签扩展函数： import nj from 'nornj'; nj.registerExtension( 'simpleFor', options => { const { props, children } = options; return props.of.map((item, index) => children({ data: [{ //注意：data参数需要传入一个每项为对象的数组；对象个数不限 loopIndex: index, loopItem: item, loopFirst: index == 0 }] })) } ); 如需要改变循环体中的loopItem等参数名，在SimpleFor标签的属性上修改在extensionConfig.simpleFor.newContext.data中设置的对象名即可，如item、index等： Test for: {itemNum} 子标签 NornJ标签还可以在子节点中附带子标签，比如标签内的、，标签内的等。 配套babel插件在运作时会将子标签连同其主标签一起进行转换。目前NornJ的babel插件暂时只支持转换1级子标签，这在大多数情况下足够用了。 比如我们需要给上面开发的Unless标签增加一个名为Otherwise的子标签，功能为在condition条件为true时渲染它的子节点。用法如下： Test unless Test otherwise 编写Otherwise标签扩展函数： import nj from 'nornj'; nj.registerExtension( 'otherwise', //注意：标签名称需要使用小写开头的camel命名方式 options => { const { props, children, tagProps //tagProps是主标签(Unless)的props对象 } = options; //把Otherwise的子节点函数添加在Unless标签的props对象上面。注意，不必在这里执行它 tagProps.otherwise = children; } ); 接着修改Unless标签的扩展函数： import nj from 'nornj'; nj.registerExtension( 'unless', options => { const { props, children } = options; if (!props.condition) { return children(); //输出Unless标签的子节点：Test unless } else if(props.otherwise != null) { return props.otherwise(); //输出Otherwise标签的子节点：Test otherwise } } ); 最后在.babelrc配置一下Otherwise的标签信息，需要设置isSubTag参数为true： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"extensionConfig\": { \"unless\": true, \"otherwise\": { \"isSubTag\": true } } } ] ] } "},"jsx-syntax/directives.html":{"url":"jsx-syntax/directives.html","title":"指令","keywords":"","body":"指令 指令是一种扩展的HTML(XML)标签属性，NornJ也为JSX提供了指令语法： Test directive 上例中的n-show即为指令语法。 指令能做什么 指令通常可以用来封装一些实用功能，以实现写更少的代码去做更多的事情为目的。具体来说NornJ的指令主要可以实现以下几种功能： 操作将传入组件的props值 封装包装组件 操作将传入组件的props值 NornJ的指令最主要的功能就是用来设置(或修改)JSX标签的属性值。比如预置指令n-show，它就是用来设置JSX标签的style.display属性： /* 实际渲染： */ 目前JSX原生的语法可以实现类似指令的效果吗？答案是可以的。通常可以使用JSX延展操作符来模拟出类似指令的效果，比如react-hanger的useInput： const newTodo = useInput(''); /* 实际渲染： */ 但是，上面这种方式也存在以下这些问题： 封装扩展的内部无法获取JSX标签已有的其他属性值，比如上例中的name=\"input\"。这在开发一些功能时会有局限。 写法与常规的JSX属性区别较大，可读性差一些。 然而NornJ的指令语法可以完美解决上述问题。 封装包装组件 设置(或修改)JSX标签的属性值是NornJ的指令最基本的功能。指令还能实现更高级的功能，可以在当前指令所在组件的外层再套自定义逻辑的包装组件。下面我们看一个简单的应用例子(使用ant-design的Tooltip组件)。 ant-design的Tooltip组件常规的写法： import { Tooltip, Button } from 'antd'; ReactDOM.render( TL ) 然而可以使用NornJ指令的扩展开发方式将上面的Tooltip组件封装在一个包装组件之中，这样就可以像下面这种方式使用： ReactDOM.render( TL ) 如上，使用了指令后组件树结构减少了一层，看起来会更加简洁清晰。上述n-tooltip指令的扩展实现方式，我们将在本章节最后详细阐述。 下面是NornJ已有内置的指令： n-show 使用n-show可以在JSX中很方便地切换标签的style.display值是否为none，当值为false时不显示： class TestComponent extends Component { render() { return ; } } ReactDOM.render(); /* 渲染结果： */ n-show指令与标签的区别 语法 特点 建议使用场景 n-show 初始渲染开销大；切换时开销小 在条件频繁切换时使用，性能会更好 初始渲染开销小；切换时开销大 在条件很少改变时使用，性能会更好 n-style 使用n-style可以在JSX中使用与html语法一致的css写法： class TestComponent extends Component { render() { //以下与效果相同 return ; } } 在n-style中也可以动态嵌入变量： const cssProp = 'padding'; class TestComponent extends Component { render() { return ; } } n-debounce 使用n-debounce可以在JSX中为input等表单元素增加防抖效果，以减少用户输入频率而提高性能： class TestComponent extends Component { onChange = e => { //每次输入后延迟一定毫秒才触发一次 console.log(e.target.value); }; render() { return ( <> ); } } 如上，n-debounce的触发事件默认为onChange。如果不写n-debounce的值，默认为100毫秒。 指定任意事件 n-debounce也可以支持onChange以外的其他事件。比如onInput，则需要在n-debounce后面添加onInput参数： class TestComponent extends Component { onInput = e => { console.log(e.target.value); }; render() { return ; } } n-mobxBind 使用n-mobxBind指令可以配合Mobx的可观察变量在及等表单元素上创建双向数据绑定，它会根据控件类型自动选取正确的方法来更新值。 基本使用方法 import { Component } from 'react'; import { observable } from 'mobx'; class TestComponent extends Component { @observable inputValue = 'test'; render() { return ; } } 如上所示，无需编写标签的onChange事件，inputValue变量已自动和标签建立了双向数据绑定的关系。 实质上，n-mobxBind的实现原理其实就是下面的语法糖形式： class TestComponent extends Component { @observable inputValue = 'test'; onChange = e => { this.inputValue = e.target.value; }; render() { return ; } } onChange事件 由于n-mobxBind默认自动设置了组件的onChange事件，但有些情况下我们可能还是需要在onChange中做一些其他的操作： class TestComponent extends Component { @observable inputValue = 'test'; onChange = e => { console.log(e.target.value); }; render() { return ; } } 如上所示，onChange事件的行为和标签原生的onChange完全相同，它会在文本框的值变化后执行。 增加防抖效果 可以使用debounce参数为n-mobxBind提供防抖效果： import { Component } from 'react'; import { observable } from 'mobx'; class TestComponent extends Component { @observable inputValue = ''; onChange = e => { console.log(e.target.value); }; render() { return ( <> ); } } 上例中的debounce参数默认值为100毫秒。也支持自定义设置，如例中为debounce加修饰符即可。 使用action更新变量 在Mobx开发中如果启动严格模式或者使用mobx-state-tree时，则须要使用action来更新变量。可按下面方式配置使用action： import { observable, action, configure } from 'mobx'; // don't allow state modifications outside actions configure({ enforceActions: true }); class TestComponent extends Component { @observable inputValue = 'test'; @action.bound setInputValue(value, args) { this.inputValue = value; //value是用户输入的新值 console.log(args); //args为控件onChange事件的全部参数，类型为数组 } render() { return ; } } 如存在camel命名法(set + 首字母大写的observable变量名)定义的action时，n-mobxBind会默认执行它来更新数据。上例中为setInputValue。 接下来我们来按控件分类列举下n-mobxBind指令可支持的场景： 绑定原生表单控件 原生表单控件包含文本框、复选框、单选按钮、选择框等，以上都可以直接使用n-mobxBind指令，会自动监听相应控件的onChange事件并正确地更新值。 文本框 单行文本框： class TestComponent extends Component { @observable inputValue = 'test'; render() { return ( <> Message is: {this.inputValue} ); } } 多行文本框： class TestComponent extends Component { @observable inputValue = 'test'; render() { return ( <> Message is: {this.inputValue} ); } } 复选框 单个复选框，绑定到布尔值： class TestComponent extends Component { @observable checked = false; render() { return ( <> {this.checked} ); } } 多个复选框，绑定到同一个数组： class TestComponent extends Component { @observable checkedNames = ['Jack', 'Mike']; render() { return ( <> Jack John Mike Checked names: {this.checkedNames} ); } } 单选按钮 class TestComponent extends Component { @observable picked = ''; render() { return ( <> One Two Picked: {this.picked} ); } } 选择框 单选时： class TestComponent extends Component { @observable selected = ''; render() { return ( <> 请选择 A B C Selected: {this.selected} ); } } 多选时，绑定到一个数组： class TestComponent extends Component { @observable selected = []; render() { return ( <> A B C Selected: {this.selected} ); } } 用渲染的动态选项： class TestComponent extends Component { @observable selected = 'A'; options = [ { text: 'One', value: 'A' }, { text: 'Two', value: 'B' }, { text: 'Three', value: 'C' } ]; render() { return ( <> {item.text} Selected: {this.selected} ); } } 绑定组件 除了上述的原生表单控件外，n-mobxBind指令也可以绑定到任意React组件上。当然，前提是该组件可能需要使用nj.registerComponent进行注册，并且设置一些必要的参数。 例如我们注册一个使用ant-design的Input组件的例子，首先是注册组件： import nj from 'nornj'; import { Input } from 'antd'; nj.registerComponent( 'ant-Input', //组件名(全局唯一)，类型为字符串 Input, //组件对象 { //组件配置参数对象 hasEventObject: true //为true时使用e.target.value获取值 } ); 上述代码在全局统一注册一次就可以了。然后便可以正常地使用n-mobxBind指令进行绑定： import { Component } from 'react'; import { observable } from 'mobx'; import { Input } from 'antd'; class TestComponent extends Component { @observable inputValue = 'test'; render() { return ; } } 注册组件 在注册很多组件时按各参数的默认值就可以了，也就是说其实可以不写nj.registerComponent的第三个参数的。但是也有组件需要配置一些参数，例如： import nj from 'nornj'; import { Cascader } from 'antd'; nj.registerComponent( 'ant-Cascader', //组件名(全局唯一)，类型为字符串 Cascader, //组件对象 { //组件配置参数对象，如果下表中的默认配置都满足要求也可以省略 needToJS: true //值被更新到该组件前，需要执行一次Mobx.toJS } ); 所有组件参数列表： 参数名 类型 默认值 作用 hasEventObject Boolean false 为true时，更新事件中使用 e.target.value} />取值。 为false时，更新事件中使用 value} />取值。 targetPropName String 'value' 如果hasEventObject参数为true，则更新事件中使用 e.target[targetPropName]} />取值。 不填时默认值是value，也就是使用e.target.value取值。 valuePropName String 'value' 被绑定控件的值属性名，即中的value属性名称。比如可以依不同组件特性修改为textValue、checked等等。 changeEventName String 'onChange' 被绑定控件的更新事件属性名，即中的onChange属性名称。比如可以依不同组件特性修改为onInput、onTextChange等等。 needToJS Boolean false 输入的新值在被更新到组件时，是否需要执行一次Mobx.toJS。例如一些需要绑定到数组值的组件可能需要设置needToJS为true，否则无法正确地更新值到相应的组件中，比如ant-design的Cascader组件。 需要进行这一步操作，是由Mobx可观察变量的特性与该组件的内部实现是否有冲突来决定的，这个有时候也无法避免。 已预置注册的组件 目前ant-design组件库已在nornj-react包中预置注册了全部组件。也就是说对于ant-design组件库无需再手工注册了，按下面方式直接引入就可以使用n-mobxBind指令。 首先需要安装babel-plugin-import插件，并在.babelrc增加以下配置： \"plugins\": [ ... [ \"import\", { \"libraryName\": \"nornj-react/antd\", \"style\": true } ], ... ] 然后这样引入使用各ant-design组件即可： import { Table, Input, Button, Pagination, Tabs, Tree, Select, Checkbox, Modal, message, Row, Col, Form, DatePicker, Icon, Steps, Divider } from 'nornj-react/antd'; //注意，此处由\"antd\"改为\"nornj-react/antd\" ... class TestComponent extends Component { @observable inputValue = 'test'; render() { return ; } } ({ setInputValue(value, args) { self.inputValue = value; //value是用户输入的新值 console.log(args); //args为控件onChange事件的全部参数，类型为数组 } })); ``` component： ```js @inject('rootStore') @observer class TestComponent extends Component { render() { return ; } } ``` 如上，`n-mstBind`会默认执行camel命名法(`set + 变量名`)定义的`action`来更新值，上例中为`setInputValue`。除此外`n-mstBind`的其他特性与上述的`n-mobxBind`完全相同。 --> 开发新的指令 NornJ的指令都是支持可扩展的，也就是说可以自行封装各种新功能。 开发一个最简单的指令 例如实现一个n-class指令，功能即为与classnames库相同： Test /* 以上渲染内容为： Test */ 上面的n-class指令实际上是一个扩展函数，使用nj.registerExtension方法注册： import nj from 'nornj'; import classNames from 'classnames'; nj.registerExtension( 'class', //注意：指令名称需要使用小写开头的camel命名方式 options => { const { tagProps, //指令所在组件的props对象，本例中为{ id: 'test' } value //指令值函数，注意它是个函数需要执行才能取到结果 } = options; //在组件渲染前，使用classNames库来设置className属性的值 tagProps.className = classNames( value() //此处返回例中的{ foo: true, bar: true } ); } ); 配置.babelrc(该例中此步骤也可以省略)： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"extensionConfig\": { \"class\": { \"isDirective\": true } } } ] ] } 这样我们就成功开发了一个n-class指令，该实例演示了NornJ指令的操作将传入组件的props值功能。 更复杂的指令 接下来我们来实现一个内部封装了包装组件的指令n-tooltip，它的作用和ant-design的Tooltip组件是一样的： TL 首先，我们组要实现一个包装组件WrappedTooltip.jsx： import React from 'react'; import { Tooltip } from 'antd'; const WrappedTooltip = ({ TooltipDirectiveTag, //指令所在组件的组件对象；如果是原生html标签的话就是标签名字符串，如div tooltipDirectiveOptions, //指令扩展函数的options对象 ...tagProps //指令所在组件的props对象 }) => { const { props, value } = tooltipDirectiveOptions; //获取指令参数 const args = props && props.arguments; return ( ); }; export default WrappedTooltip; 然后使用nj.registerExtension方法注册扩展函数： import nj from 'nornj'; import WrappedTooltip from './WrappedTooltip.jsx'; nj.registerExtension( 'tooltip', //注意：指令名称需要使用小写开头的camel命名方式 options => { const { tagName, //指令所在组件对象 tagProps, //指令所在组件的props对象 setTagName //运行此函数，可以修改当前即将渲染的组件对象 } = options; setTagName(WrappedTooltip); //将当前渲染的组件修改为包装组件 tagProps.TooltipDirectiveTag = tagName; //传递指令所在组件对象到包装组件中 tagProps.tooltipDirectiveOptions = options; //传递指令的options到包装组件中 } ); 上例有个需要注意的地方，就是TooltipDirectiveTag和tooltipDirectiveOptions参数的命名应当特例化而避免和其他指令的重复。因为这样才能适应同时存在多个含有包装组件的指令的场景，比如。 这样n-tooltip指令就开发完成了，还可以变更参数控制显示方向： TL TL 数据绑定指令 数据绑定指令一般用来将传入的值与表单控件建立双向绑定关系，n-mobxBind就是一个数据绑定指令，这种特殊的指令同样也可以支持扩展。下面我们先来实现一个用于React Hooks Api的n-bind指令，用法如下： function TestBind() { const $count = useState(100), //useState的返回值是一个数组，需要将它传到n-bind指令中 [count] = $count; //如有需要，可以再从$count解构出count和setCount return ( console.log(e.target.value)} /> input: {count} ); } 编写n-bind的扩展函数： nj.registerExtension( 'bind', options => { const { tagProps, value } = options; const [state, setState] = value(); //按useState的返回值结构来解构变量 tagProps.value = state; //设置当前组件的value对象 const _onChange = tagProps.onChange; //暂存当前组件的onChange事件函数 tagProps.onChange = function (e) { //重新设置onChange事件 setState(e.target.value); //更新变量值 _onChange.apply(null, arguments) //执行组件的onChange事件，并传递参数 }; } ); 用如上的方式我们就成功实现了一个简单的数据绑定指令n-bind。但是它目前只支持文本框，下面我们再让它支持单选按钮，用法如下： function TestBind() { const $count = useState(100), [count] = $count; const $num = useState(''), [num] = $num; return ( console.log(e.target.value)} /> input: {count} radio: {num} ); } 修改n-bind的扩展函数： nj.registerExtension( 'bind', options => { const { tagProps, value } = options; const [state, setState] = value(); //按useState的返回值结构来解构变量 if(tagProps.type == 'radio') { //单选按钮 tagProps.checked = tagProps.value === state; //判断当前单选按钮组件是否为选中状态 } else { //文本框 tagProps.value = state; //设置当前文本框组件的value对象 } const _onChange = tagProps.onChange; //暂存当前组件的onChange事件函数 tagProps.onChange = function (e) { //重新设置onChange事件 setState(e.target.value); //更新变量值 _onChange.apply(null, arguments) //执行组件的onChange事件，并传递参数 }; } ); 如上，我们就实现了一个同时支持文本框和单选按钮的n-bind指令。而判断控件类型的逻辑，则是利用了NornJ指令能取到标签的所有其他props的特性。 接下来还有一种更复杂的场景，比如我们需要实现一个支持React Class组件的n-stateBind指令，用法如下： class TestStateBind extends Component { state = { count: 100, foo: { count: 100 }, bar: { baz: { count: 100 } } }; render() { return ( console.log(e.target.value)} /> input: {this.state.foo.count} ); } } 首先需要修改.babelrc配置： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"extensionConfig\": { \"stateBind\": { \"isDirective\": true, \"isBindable\": true //设置isBindable为true，在取指令的值时会返回特殊的格式 } } } ] ] } 然后编写n-stateBind的扩展函数： nj.registerExtension( 'stateBind', options => { const { tagProps, value, context: { $this //对于Class组件，可以这样取出当前组件的实例对象\"$this\"变量，也就是组件的实例引用\"this\" } } = options; const _value = value(); //注意，这里的value返回值是个特殊的对象结构，各属性如示例下面的表格所示 tagProps.value = _value.value; //设置当前组件的value对象 const _onChange = tagProps.onChange; //暂存当前组件的onChange事件函数 tagProps.onChange = function (e) { //重新设置onChange事件 $this.setState( //使用组件实例上的setState函数更新值 putStateValue(_value, e.target.value), //用自定义的putStateValue函数创建出setState所需的参数结构，下面有putStateValue的详细实现 () => _onChange.apply($this, arguments) //执行组件的onChange事件，并传递参数 ); }; } ); 上面扩展函数代码中的_value对象的各属性为： 属性名 类型 作用 value Any 指令值，例：中的this.state.foo.bar值。 prop String 指令值的属性名，例：中的'bar'。 source Object 指令值的当前层级所属对象引用，例：中的this.state.foo。 parent Object 指令值的当前层级所属对象的父级对象引用，例：中的this.state。 但是parent对象也是一个包含source属性的对象，所以可以向上级递归取出所有层级的对象引用。 最后是putStateValue函数的实现： function putStateValue(value, ret) { return value.prop == 'state' ? ret : putStateValue(value.parent, { [value.prop]: ret }); } putStateValue函数的实现逻辑其实很简单，就是递归获取this.state.foo.count当前层级值的parent属性，然后按相应格式构造出setState函数所需的参数结构即可。 如上，我们就实现了一个更复杂的数据绑定指令n-stateBind。其实n-mobxBind指令的实现方式也与本例中的n-stateBind类似。 为什么NornJ中只内置实现了支持Mobx的数据绑定指令？答案其实很简单：因为Mobx可观察变量的特性与操作方式，更适合此种指令方案的语法结构等各方面，可以更好地呈现双向数据绑定的优势而提高开发效率。 "},"tagged-templates-syntax/expressions.html":{"url":"tagged-templates-syntax/expressions.html","title":"表达式扩展语法","keywords":"","body":"表达式扩展语法 NornJ提供了一种在tagged templates语法中写表达式的功能，称为NornJ 表达式。主要用作增强现有的JS表达式，并实现过滤器等内建的新语法。使用方式很简单，即标签名为n的tagged templates： ReactDOM.render( <> ) /* 渲染结果： */ 表达式能做什么 简单地说，NornJ表达式中内建了一些常规JS语法不支持的特性： 过滤器 过滤器是什么？是一种在模板引擎(或含有模板引擎的框架，如Vue)中常见的功能，主要用于过滤展示数据。可参考Nunjucks的文档：https://mozilla.github.io/nunjucks/templating.html#filters。 NornJ过滤器的基本用法： {n`1234.567 | currency(2.05 | toInteger) | isString`} /* 例中先执行currency过滤器返回\"$1234.57\"，然后再执行isString过滤器判断是否字符串。 渲染结果：true */ 如上，过滤器的语法的常规模板引擎一致使用|符号作为分隔符，并且还支持为过滤器传参数和嵌套过滤器。更重要的是，还可以扩展出新的过滤器。 运算符 NornJ表达式中除了支持常规运算符外，还可以支持一些在常规JS语法中不支持的运算符，比如范围运算符..： {n`(1 .. 5).join('-')`} /* 例中\"1 .. 5\"的运算结果是一个含1-5的数组(即\"[1, 2, 3, 4, 5]\")，然后再执行数组的join方法用\"-\"连接每项。 渲染结果：1-2-3-4-5 */ 如上，此类自定义运算符是可以在NornJ表达式中同常规的JS语法一起运作。同过滤器一样，运算符也可以支持扩展出新的。 适配常规 JS 表达式 NornJ表达式对于常规的 JS 语法有非常好的适配性，例如下面列举的这些常用场景都可以支持： const Test = () => ( <> {n`1 + 2 * 3 - 4 / 5`} {n`1 4)`} {n`'abc'.trim() + 'def'.substr(1).length`} ); 使用变量 借助于Babel 插件的转换能力，NornJ表达式内可以直接使用当前作用域内可用的变量： const Test = props => { const str = 'abc'; const str2 = 'def'; return ( <> {n`props.a > (2 + 1) && !props.b {n`str.trim() + str2.substr(1).length`} ); }; 除了上述使用方法外，变量也可以通过tagged templates参数方式传入，效果是一样的： const Test = props => { const str = 'abc'; const str2 = 'def'; return ( <> {n`${props.a} > (2 + 1) && ${props}.b {n`${str}.trim() + ${str2}.substr(1).length`} ); }; 每个NornJ表达式计算后都会返回正确的类型，所以也可以和外部 JS 语法混合： const Test = props => ( <> {n`${props.a} > (2 + 1)` && n`${props}.b ); 插入过滤器等自定义语法 NornJ表达式内可以同时使用常规 JS 语法和过滤器等自定义语法，这正是它的特色： const Test = () => { const str = 'abc'; return ( <> {n`str.trim() | upperFirst`} {n`12345678 | currency`} {n`(1 .. 100).length * 100`} ); }; 表达式内目前不支持的语法 NornJ表达式虽然适配性很强，但当前还是有一些不支持的语法，如下： //注意，以下为一些目前不支持的语法 const Test = props => ( <> {n`!!12345`} {/* 只有1个!是支持的；多个!暂不支持 */} {n`12345++`} {/* 暂不支持自增等运算 */} {n`+12345`} {/* 暂不支持一元运算(!除外) */} {n`'12345'.map((item, i) => item)`} {/* 暂不支持定义函数体 */} ); //上面不支持的语法可以用原生JS语法弥补，这样改写： const Test2 = props => ( <> {!n`!12345`} {n`12345`++} {+n`12345`} {n`'12345'.map(${(item, i) => item})`} ); 不过，日后不排除NornJ会支持上述语法的可能性，已支持的语法已足够支撑常规开发使用。 另外，NornJ表达式的目标定位是为现有 JS 语法做增强，故它的内部或许并不需要实现全部的 JS 表达式。 过滤器 NornJ过滤器提供了一些常用内置功能，且完全可以支持用户扩展。 过滤器的管道与函数形式 NornJ的过滤器除了支持管道形式写法外，还可以支持用函数形式写法，效果是一样的： const Test = () => { const str = 'abc'; return ( <> {/* 管道形式 */} {n`str.trim() | upperFirst`} {n`12345678 | currency`} {/* 函数形式 */} {n`upperFirst(str.trim())`} {n`currency(12345678)`} ); }; 我们不妨对比一下过滤器的管道形式与函数形式写法，可发现管道形式的主要优势在于对于数据过滤看起来更为直观。 下面是NornJ的内置过滤器： 注意，内置过滤器只包含一些基础功能，例如很大一部分是NornJ底层必要使用的工具函数。NornJ的定位并不是一个类似Lodash的工具函数库，它的目标只是为常规JS开发提供过滤器这种新的扩展方式而已。 字符串处理 upperFirst upperFirst可以实现首字母大写： const Test = () => ( <> {n`'jack' | upperFirst`} ); //输出：Jack lowerFirst lowerFirst可以实现首字母小写： const Test = () => ( <> {n`'Jack' | lowerFirst`} ); //输出：jack camelCase camelCase可以将kebab-case字符串转换为camel-case： const Test = () => ( <> {n`'margin-left' | camelCase`} ); //输出：marginLeft 类型测定 isObject isObject用于检查类型是否为对象： const Test = ({ children }) => ( <> {n`children | isObject`} ); //输出：true isNumber isNumber用于检查类型是否为数字： const Test = ({ children }) => ( <> {n`children.length | isNumber`} ); //输出：true isString isString用于检查类型是否为字符串： const Test = ({ children }) => ( <> {n`children.length | isString`} ); //输出：false isArrayLike isArrayLike用于检查类型是否为类数组： const Test = ({ children }) => ( <> {n`children | isArrayLike`} ); //输出：true currency currency可以将数字转换货币形式： const Test = () => ( <> {n`98765 | currency`} {/* '$98,765.00' */} {n`98765.32132 | currency(2)`} {/* '$98,765.32' */} {n`98765.321 | currency(0, '￥')`} {/* '￥98,765' */} {n`'abc' | currency(2, '$', '-')`} {/* '-' */} ); 参数 用法 类型 默认值 作用 decimals 98765 | currency(decimals) Int 2 小数位 symbol 98765 | currency(2, symbol) String '$' 钱币符号 placeholder 98765 | currency(2, '￥', placeholder) String '' 如传入非数字，则输出占位符 另外，symbol和placeholder还可以进行全局配置： import nj from 'nornj'; nj.filterConfig.currency.symbol = '￥'; nj.filterConfig.currency.placeholder = '-'; toJS toJS即为Mobx的toJS方法： const Test = () => { const view = useLocalStore(() => ({ texts: ['abc', 'def'] })); return ( <> {JSON.stringify(n`view | toJS`)} ); }; 使用 Lodash NornJ的过滤器可以使用Lodash库的全部工具函数。它是一个过滤器的扩展，需要先这样全局引入一次： import 'nornj/lib/filter/lodash'; 然后就可以在NornJ表达式中使用了： const Test = () => ( <> {n`'-abc-' | repeat(3)`} {/* '-abc--abc--abc-' */} {n`'-abc-' | endsWith('bc-')`} {/* true */} {n`'Foo Bar' | snakeCase`} {/* 'foo_bar' */} ); 更多Lodash过滤器的使用方法请查看Lodash 文档。 开发新的过滤器 NornJ的过滤器都是支持可扩展的，可以自行封装各种新功能。 每个过滤器实际上是一个扩展函数，使用nj.registerFilter方法注册： import nj from 'nornj'; nj.registerFilter('2x', num => num * 2); //支持一次注册过个过滤器 nj.registerFilter({ '3x': num => num * 3, '4x': num => num * 4 }); console.log(n`100 | 2x | 3x | 4x`); //输出：2400 过滤器可以支持参数： import nj from 'nornj'; //从扩展函数的第二个参数开始定义过滤器的每个参数 nj.registerFilter('times', (num, times) => num * times); console.log(n`100 | times(10)`); //输出：1000 过滤器还可以支持嵌套： console.log(n`100 | times((10 * 2) | 3x)`); //输出：6000 上例中(10 * 2) | 3x的乘法运算需要加括号，是因为过滤器的运算优先级是最高的，并从左到右按顺序执行。 运算符 NornJ表达式中除了可以使用常规 JS 运算符外，还内置支持一些自定义的运算符，如%%、..等，并且还支持扩展出新的运算符。 可选链 NornJ表达式中的链式调用语法，默认全部都是可选链： const Test = props => ( <> {n`props.abc.length > 1`} {/* 不会报错 */} {props.abc.length > 1} {/* 报 props.abc 为 undefined 错误 */} {props?.abc?.length > 1} {/* 不会报错(使用 Babel 转换可选链语法) */} ); NornJ的可选链运算符在以下各种场景都可以正常使用，不会报错： const Test = props => ( <> {n`props[abc].length > 1`} {n`props.abc.substr(1) > 1`} {n`props[abc]().length > 1`} ); 与 Babel 转换的可选链语法(?.)相比，NornJ的可选链运算符由于不须要写?，所以使用和阅读都会很便捷。 但由于NornJ表达式内部目前不能支持定义函数体，所以有函数的场景可以这样使用： const Test = props => ( <> {/* 将函数体作为外部参数传入 NornJ 表达式 */} {n`props.data.map(${(item, i) => { return {item} }})`} ); 范围运算符 范围运算符可以快速生成数组： const Test = () => { const a = 10, b = 20; return ( <> {n`1 .. 10`} {/* [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] */} {n`(1 .. 10).length`} {/* 10 */} {n`(a .. b).length | includes(15)`} {/* true */} ); }; 半闭区间范围运算符 ..是闭区间的，NornJ还提供了它的半闭区间版本： const Test = () => { const a = 10, b = 20; return ( <> {n`1 .. {/* [1, 2, 3, 4, 5, 6, 7, 8, 9] */} {n`(1 .. {/* 9 */} {n`(a .. {/* false */} ); }; 飞船运算符 飞船运算符是一种比较运算，它按照大于、小于、等于三种结果，分别返回1、-1，0三种值： const Test = () => ( <> {n`1 10`} {/* -1 */} {n`1 1`} {/* 0 */} {n`10 1`} {/* 1 */} ); 向下取整运算符 NornJ内置了一种可实现向下取整的除法运算符，它的底层实现是Math.floor(value1 / value2)： const Test = () => ( <> {n`100 %% 30`} {/* 3 */} {n`56.78 %% 5`} {/* 11 */} {n`-56.78 %% 5`} {/* -12 */} ); 开发新的运算符 NornJ的运算符也都是支持可扩展的，可以自行封装各种新功能。 NornJ中的运算符本质上其实是过滤器的一种语法糖形式，目前可以做到自定义扩展出各种二元运算符。 每个运算符实际上是一个扩展函数，和过滤器一样使用nj.registerFilter方法注册： import nj from 'nornj'; //注册***运算符，功能为先进行乘法运算后，再乘上3倍 nj.registerFilter('***', (num, times) => num * times * 3); //支持一次注册过个运算符，功能和***类似 nj.registerFilter({ '****': (num, times) => num * times * 4, '*****': (num, times) => num * times * 5 }); 然后需要配置一下.babelrc： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"filterConfig\": { \"***\": { isOperator: true }, \"****\": { isOperator: true }, \"*****\": { isOperator: true } } } ] ] } 接着就可以在NornJ表达式中使用了： console.log(n`100***10`); //输出：100 * 10 * 3 = 3000 console.log(n`100***10****10`); //输出：100 * 10 * 3 * 10 * 4 = 120000 console.log(n`100***10****10*****10`); //输出：100 * 10 * 3 * 10 * 4 * 10 * 5 = 6000000 运算符的命名目前是有限制的，如包含下列字符则需要做特殊处理： [ '_', '#', '.', '>', ' 如运算符名称中包名含上述字符，则需要这样注册： import nj from 'nornj'; nj.registerFilter( '*.*', (num, times) => num * times * 3, { alias: '3x' //添加别名 } ); nj.registerFilter({ '*..*': { filter: (num, times) => num * times * 4, options: { alias: '4x' } }, '*...*': { filter: (num, times) => num * times * 5, options: { alias: '5x' } } }); 然后需要配置一下.babelrc： { ... \"plugins\": [ [ \"nornj-in-jsx\", { \"filterConfig\": { \"*.*\": { isOperator: true, alias: '3x' }, \"*..*\": { isOperator: true, alias: '4x' }, \"*...*\": { isOperator: true, alias: '5x' } } } ] ] } 接着就可以在NornJ表达式中使用了： console.log(n`100*.*10`); //输出：100 * 10 * 3 = 3000 console.log(n`100*.*10*..*10`); //输出：100 * 10 * 3 * 10 * 4 = 120000 console.log(n`100*.*10*..*10*...*10`); //输出：100 * 10 * 3 * 10 * 4 * 10 * 5 = 6000000 "}}